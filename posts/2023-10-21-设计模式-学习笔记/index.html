<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>设计模式学习笔记 | Cheney's blog</title>
<meta name=keywords content><meta name=description content="七大原则 设计模式中的七大原则是指的是一组指导性原则，它们帮助开发人员编写更可维护、可扩展、可重用和可理解的代码。这些原则有助于创建高质量的软件设计。
类别 原则名称 描述 创建类 单一职责原则 (Single Responsibility Principle ) 一个类应该只有一个引起变化的原因，即一个类应该只有一个单一的责任。 开放封闭原则 (Open/Closed Principle) 软件实体应该是开放于扩展的，但封闭于修改的，可以通过添加新功能来扩展系统，而不需要修改已存在的代码。 类关系 里氏替换原则 (Liskov Substitution Principle ) 子类必须能够替换其基类而不引起不良的行为，子类应该保持对基类的兼容性，不应该破坏父类的预期行为。 依赖倒置原则 (Dependency Inversion Principle) 高层模块不应该依赖于低层模块，二者都应该依赖于抽象/接口，抽象/接口不应该依赖于具体细节，具体细节应该依赖于抽象/接口。 接口隔离原则 (Interface Segregation Principle ) 客户端不应该被迫依赖于它们不使用的接口，接口应该被细分，使得客户端只需知道与其相关的接口。 组件复用 迪米特法则 (Law of Demeter) 每个单元应该只与其紧密相关的少数其他单元进行交互，减少模块之间的耦合性，使系统更加灵活和易于维护。 合成/聚合复用原则 (Composite/Aggregate Reuse Principle) 尽量使用合成/聚合关系来实现代码重用，而不是继承，降低类之间的耦合性，使系统更灵活。 常见设计模式 类别 模式名称 描述 行为型模式 观察者模式 (Observer Pattern) 定义了对象之间的一对多依赖关系，使得一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。 策略模式 (Strategy Pattern) 定义一系列算法，将每个算法封装成一个对象，并使它们可以相互替换。客户端可以在运行时选择所需的算法。 命令模式 (Command Pattern) 将请求或操作封装成一个对象，允许将请求参数化、队列化、撤销和重做操作。 模板方法模式 (Template Method Pattern) 定义一个算法的骨架，将一些步骤延迟到子类实现，以便在不改变算法结构的情况下重定义特定步骤。 结构型模式 适配器模式 (Adapter Pattern) 允许将一个类的接口转换成另一个类的接口，使不兼容的接口能够一起工作。 装饰器模式 (Decorator Pattern) 允许动态地将责任附加到对象，扩展对象的功能而不影响其他对象。 组合模式 (Composite Pattern) 允许将对象组合成树形结构以表示部分-整体层次结构。客户端可以统一处理单个对象和组合对象。 代理模式 (Proxy Pattern) 提供了一个代理对象，控制对另一个对象的访问，允许在访问实际对象前后执行额外的操作。 创建型模式 工厂方法模式 (Factory Method Pattern) 定义一个创建对象的接口，但将具体的实例化推迟到子类，以便子类决定要实例化的具体类。 抽象工厂模式 (Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。 单例模式 (Singleton Pattern) 保证一个类只有一个实例，并提供全局访问点。 建造者模式 (Builder Pattern) 将一个复杂对象的构建过程分离成多个步骤，允许相同的构建过程创建不同的表示。 原型模式 (Prototype Pattern) 允许通过复制现有对象来创建新对象，通常用于创建代价高昂的对象。 工厂 工厂方法模式 工厂模式是一种常见的设计模式，用于创建对象。它提供了一种方式来创建对象，而不需要在代码中直接使用构造函数，这有助于解耦代码，提高可维护性和可扩展性。"><meta name=author content="Me"><link rel=canonical href=https://cheneydev.github.io/posts/2023-10-21-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="设计模式学习笔记"><meta property="og:description" content="七大原则 设计模式中的七大原则是指的是一组指导性原则，它们帮助开发人员编写更可维护、可扩展、可重用和可理解的代码。这些原则有助于创建高质量的软件设计。
类别 原则名称 描述 创建类 单一职责原则 (Single Responsibility Principle ) 一个类应该只有一个引起变化的原因，即一个类应该只有一个单一的责任。 开放封闭原则 (Open/Closed Principle) 软件实体应该是开放于扩展的，但封闭于修改的，可以通过添加新功能来扩展系统，而不需要修改已存在的代码。 类关系 里氏替换原则 (Liskov Substitution Principle ) 子类必须能够替换其基类而不引起不良的行为，子类应该保持对基类的兼容性，不应该破坏父类的预期行为。 依赖倒置原则 (Dependency Inversion Principle) 高层模块不应该依赖于低层模块，二者都应该依赖于抽象/接口，抽象/接口不应该依赖于具体细节，具体细节应该依赖于抽象/接口。 接口隔离原则 (Interface Segregation Principle ) 客户端不应该被迫依赖于它们不使用的接口，接口应该被细分，使得客户端只需知道与其相关的接口。 组件复用 迪米特法则 (Law of Demeter) 每个单元应该只与其紧密相关的少数其他单元进行交互，减少模块之间的耦合性，使系统更加灵活和易于维护。 合成/聚合复用原则 (Composite/Aggregate Reuse Principle) 尽量使用合成/聚合关系来实现代码重用，而不是继承，降低类之间的耦合性，使系统更灵活。 常见设计模式 类别 模式名称 描述 行为型模式 观察者模式 (Observer Pattern) 定义了对象之间的一对多依赖关系，使得一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。 策略模式 (Strategy Pattern) 定义一系列算法，将每个算法封装成一个对象，并使它们可以相互替换。客户端可以在运行时选择所需的算法。 命令模式 (Command Pattern) 将请求或操作封装成一个对象，允许将请求参数化、队列化、撤销和重做操作。 模板方法模式 (Template Method Pattern) 定义一个算法的骨架，将一些步骤延迟到子类实现，以便在不改变算法结构的情况下重定义特定步骤。 结构型模式 适配器模式 (Adapter Pattern) 允许将一个类的接口转换成另一个类的接口，使不兼容的接口能够一起工作。 装饰器模式 (Decorator Pattern) 允许动态地将责任附加到对象，扩展对象的功能而不影响其他对象。 组合模式 (Composite Pattern) 允许将对象组合成树形结构以表示部分-整体层次结构。客户端可以统一处理单个对象和组合对象。 代理模式 (Proxy Pattern) 提供了一个代理对象，控制对另一个对象的访问，允许在访问实际对象前后执行额外的操作。 创建型模式 工厂方法模式 (Factory Method Pattern) 定义一个创建对象的接口，但将具体的实例化推迟到子类，以便子类决定要实例化的具体类。 抽象工厂模式 (Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。 单例模式 (Singleton Pattern) 保证一个类只有一个实例，并提供全局访问点。 建造者模式 (Builder Pattern) 将一个复杂对象的构建过程分离成多个步骤，允许相同的构建过程创建不同的表示。 原型模式 (Prototype Pattern) 允许通过复制现有对象来创建新对象，通常用于创建代价高昂的对象。 工厂 工厂方法模式 工厂模式是一种常见的设计模式，用于创建对象。它提供了一种方式来创建对象，而不需要在代码中直接使用构造函数，这有助于解耦代码，提高可维护性和可扩展性。"><meta property="og:type" content="article"><meta property="og:url" content="https://cheneydev.github.io/posts/2023-10-21-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:image" content="https://cheneydev.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-22T22:28:22+08:00"><meta property="article:modified_time" content="2023-10-22T22:28:22+08:00"><meta property="og:site_name" content="Cheney Wang"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cheneydev.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="设计模式学习笔记"><meta name=twitter:description content="七大原则 设计模式中的七大原则是指的是一组指导性原则，它们帮助开发人员编写更可维护、可扩展、可重用和可理解的代码。这些原则有助于创建高质量的软件设计。
类别 原则名称 描述 创建类 单一职责原则 (Single Responsibility Principle ) 一个类应该只有一个引起变化的原因，即一个类应该只有一个单一的责任。 开放封闭原则 (Open/Closed Principle) 软件实体应该是开放于扩展的，但封闭于修改的，可以通过添加新功能来扩展系统，而不需要修改已存在的代码。 类关系 里氏替换原则 (Liskov Substitution Principle ) 子类必须能够替换其基类而不引起不良的行为，子类应该保持对基类的兼容性，不应该破坏父类的预期行为。 依赖倒置原则 (Dependency Inversion Principle) 高层模块不应该依赖于低层模块，二者都应该依赖于抽象/接口，抽象/接口不应该依赖于具体细节，具体细节应该依赖于抽象/接口。 接口隔离原则 (Interface Segregation Principle ) 客户端不应该被迫依赖于它们不使用的接口，接口应该被细分，使得客户端只需知道与其相关的接口。 组件复用 迪米特法则 (Law of Demeter) 每个单元应该只与其紧密相关的少数其他单元进行交互，减少模块之间的耦合性，使系统更加灵活和易于维护。 合成/聚合复用原则 (Composite/Aggregate Reuse Principle) 尽量使用合成/聚合关系来实现代码重用，而不是继承，降低类之间的耦合性，使系统更灵活。 常见设计模式 类别 模式名称 描述 行为型模式 观察者模式 (Observer Pattern) 定义了对象之间的一对多依赖关系，使得一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。 策略模式 (Strategy Pattern) 定义一系列算法，将每个算法封装成一个对象，并使它们可以相互替换。客户端可以在运行时选择所需的算法。 命令模式 (Command Pattern) 将请求或操作封装成一个对象，允许将请求参数化、队列化、撤销和重做操作。 模板方法模式 (Template Method Pattern) 定义一个算法的骨架，将一些步骤延迟到子类实现，以便在不改变算法结构的情况下重定义特定步骤。 结构型模式 适配器模式 (Adapter Pattern) 允许将一个类的接口转换成另一个类的接口，使不兼容的接口能够一起工作。 装饰器模式 (Decorator Pattern) 允许动态地将责任附加到对象，扩展对象的功能而不影响其他对象。 组合模式 (Composite Pattern) 允许将对象组合成树形结构以表示部分-整体层次结构。客户端可以统一处理单个对象和组合对象。 代理模式 (Proxy Pattern) 提供了一个代理对象，控制对另一个对象的访问，允许在访问实际对象前后执行额外的操作。 创建型模式 工厂方法模式 (Factory Method Pattern) 定义一个创建对象的接口，但将具体的实例化推迟到子类，以便子类决定要实例化的具体类。 抽象工厂模式 (Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。 单例模式 (Singleton Pattern) 保证一个类只有一个实例，并提供全局访问点。 建造者模式 (Builder Pattern) 将一个复杂对象的构建过程分离成多个步骤，允许相同的构建过程创建不同的表示。 原型模式 (Prototype Pattern) 允许通过复制现有对象来创建新对象，通常用于创建代价高昂的对象。 工厂 工厂方法模式 工厂模式是一种常见的设计模式，用于创建对象。它提供了一种方式来创建对象，而不需要在代码中直接使用构造函数，这有助于解耦代码，提高可维护性和可扩展性。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cheneydev.github.io/posts/"},{"@type":"ListItem","position":2,"name":"设计模式学习笔记","item":"https://cheneydev.github.io/posts/2023-10-21-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"设计模式学习笔记","name":"设计模式学习笔记","description":"七大原则 设计模式中的七大原则是指的是一组指导性原则，它们帮助开发人员编写更可维护、可扩展、可重用和可理解的代码。这些原则有助于创建高质量的软件设计。\n类别 原则名称 描述 创建类 单一职责原则 (Single Responsibility Principle ) 一个类应该只有一个引起变化的原因，即一个类应该只有一个单一的责任。 开放封闭原则 (Open/Closed Principle) 软件实体应该是开放于扩展的，但封闭于修改的，可以通过添加新功能来扩展系统，而不需要修改已存在的代码。 类关系 里氏替换原则 (Liskov Substitution Principle ) 子类必须能够替换其基类而不引起不良的行为，子类应该保持对基类的兼容性，不应该破坏父类的预期行为。 依赖倒置原则 (Dependency Inversion Principle) 高层模块不应该依赖于低层模块，二者都应该依赖于抽象/接口，抽象/接口不应该依赖于具体细节，具体细节应该依赖于抽象/接口。 接口隔离原则 (Interface Segregation Principle ) 客户端不应该被迫依赖于它们不使用的接口，接口应该被细分，使得客户端只需知道与其相关的接口。 组件复用 迪米特法则 (Law of Demeter) 每个单元应该只与其紧密相关的少数其他单元进行交互，减少模块之间的耦合性，使系统更加灵活和易于维护。 合成/聚合复用原则 (Composite/Aggregate Reuse Principle) 尽量使用合成/聚合关系来实现代码重用，而不是继承，降低类之间的耦合性，使系统更灵活。 常见设计模式 类别 模式名称 描述 行为型模式 观察者模式 (Observer Pattern) 定义了对象之间的一对多依赖关系，使得一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。 策略模式 (Strategy Pattern) 定义一系列算法，将每个算法封装成一个对象，并使它们可以相互替换。客户端可以在运行时选择所需的算法。 命令模式 (Command Pattern) 将请求或操作封装成一个对象，允许将请求参数化、队列化、撤销和重做操作。 模板方法模式 (Template Method Pattern) 定义一个算法的骨架，将一些步骤延迟到子类实现，以便在不改变算法结构的情况下重定义特定步骤。 结构型模式 适配器模式 (Adapter Pattern) 允许将一个类的接口转换成另一个类的接口，使不兼容的接口能够一起工作。 装饰器模式 (Decorator Pattern) 允许动态地将责任附加到对象，扩展对象的功能而不影响其他对象。 组合模式 (Composite Pattern) 允许将对象组合成树形结构以表示部分-整体层次结构。客户端可以统一处理单个对象和组合对象。 代理模式 (Proxy Pattern) 提供了一个代理对象，控制对另一个对象的访问，允许在访问实际对象前后执行额外的操作。 创建型模式 工厂方法模式 (Factory Method Pattern) 定义一个创建对象的接口，但将具体的实例化推迟到子类，以便子类决定要实例化的具体类。 抽象工厂模式 (Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。 单例模式 (Singleton Pattern) 保证一个类只有一个实例，并提供全局访问点。 建造者模式 (Builder Pattern) 将一个复杂对象的构建过程分离成多个步骤，允许相同的构建过程创建不同的表示。 原型模式 (Prototype Pattern) 允许通过复制现有对象来创建新对象，通常用于创建代价高昂的对象。 工厂 工厂方法模式 工厂模式是一种常见的设计模式，用于创建对象。它提供了一种方式来创建对象，而不需要在代码中直接使用构造函数，这有助于解耦代码，提高可维护性和可扩展性。","keywords":[],"articleBody":"七大原则 设计模式中的七大原则是指的是一组指导性原则，它们帮助开发人员编写更可维护、可扩展、可重用和可理解的代码。这些原则有助于创建高质量的软件设计。\n类别 原则名称 描述 创建类 单一职责原则 (Single Responsibility Principle ) 一个类应该只有一个引起变化的原因，即一个类应该只有一个单一的责任。 开放封闭原则 (Open/Closed Principle) 软件实体应该是开放于扩展的，但封闭于修改的，可以通过添加新功能来扩展系统，而不需要修改已存在的代码。 类关系 里氏替换原则 (Liskov Substitution Principle ) 子类必须能够替换其基类而不引起不良的行为，子类应该保持对基类的兼容性，不应该破坏父类的预期行为。 依赖倒置原则 (Dependency Inversion Principle) 高层模块不应该依赖于低层模块，二者都应该依赖于抽象/接口，抽象/接口不应该依赖于具体细节，具体细节应该依赖于抽象/接口。 接口隔离原则 (Interface Segregation Principle ) 客户端不应该被迫依赖于它们不使用的接口，接口应该被细分，使得客户端只需知道与其相关的接口。 组件复用 迪米特法则 (Law of Demeter) 每个单元应该只与其紧密相关的少数其他单元进行交互，减少模块之间的耦合性，使系统更加灵活和易于维护。 合成/聚合复用原则 (Composite/Aggregate Reuse Principle) 尽量使用合成/聚合关系来实现代码重用，而不是继承，降低类之间的耦合性，使系统更灵活。 常见设计模式 类别 模式名称 描述 行为型模式 观察者模式 (Observer Pattern) 定义了对象之间的一对多依赖关系，使得一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。 策略模式 (Strategy Pattern) 定义一系列算法，将每个算法封装成一个对象，并使它们可以相互替换。客户端可以在运行时选择所需的算法。 命令模式 (Command Pattern) 将请求或操作封装成一个对象，允许将请求参数化、队列化、撤销和重做操作。 模板方法模式 (Template Method Pattern) 定义一个算法的骨架，将一些步骤延迟到子类实现，以便在不改变算法结构的情况下重定义特定步骤。 结构型模式 适配器模式 (Adapter Pattern) 允许将一个类的接口转换成另一个类的接口，使不兼容的接口能够一起工作。 装饰器模式 (Decorator Pattern) 允许动态地将责任附加到对象，扩展对象的功能而不影响其他对象。 组合模式 (Composite Pattern) 允许将对象组合成树形结构以表示部分-整体层次结构。客户端可以统一处理单个对象和组合对象。 代理模式 (Proxy Pattern) 提供了一个代理对象，控制对另一个对象的访问，允许在访问实际对象前后执行额外的操作。 创建型模式 工厂方法模式 (Factory Method Pattern) 定义一个创建对象的接口，但将具体的实例化推迟到子类，以便子类决定要实例化的具体类。 抽象工厂模式 (Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。 单例模式 (Singleton Pattern) 保证一个类只有一个实例，并提供全局访问点。 建造者模式 (Builder Pattern) 将一个复杂对象的构建过程分离成多个步骤，允许相同的构建过程创建不同的表示。 原型模式 (Prototype Pattern) 允许通过复制现有对象来创建新对象，通常用于创建代价高昂的对象。 工厂 工厂方法模式 工厂模式是一种常见的设计模式，用于创建对象。它提供了一种方式来创建对象，而不需要在代码中直接使用构造函数，这有助于解耦代码，提高可维护性和可扩展性。\n解决的问题：\n工厂模式解决了对象的创建过程与其使用的代码之间的耦合问题。它可以隐藏对象的创建细节，使代码更加灵活，降低了代码的复杂性。\n现实中的例子：\n想象一家汽车工厂，它生产各种类型的汽车，如轿车、卡车、SUV等。客户只需要告诉工厂他们需要哪种类型的汽车，而不必亲自制造汽车。工厂会负责创建适当类型的汽车并将其交付给客户。\nJava 示例代码：\n// 创建一个接口或抽象类，表示要创建的对象 interface Vehicle { void drive(); } // 创建具体的汽车类 class Car implements Vehicle { @Override public void drive() { System.out.println(\"Driving a car.\"); } } class Truck implements Vehicle { @Override public void drive() { System.out.println(\"Driving a truck.\"); } } // 创建一个工厂类来生产汽车 class VehicleFactory { public Vehicle createVehicle(String type) { if (\"car\".equalsIgnoreCase(type)) { return new Car(); } else if (\"truck\".equalsIgnoreCase(type)) { return new Truck(); } else { return null; } } } 适用场景：\n当对象的创建过程比较复杂，需要隐藏细节时。 当需要根据条件动态选择创建对象的类型时。 当希望减少代码中的直接构造函数调用。 如何实现：\n创建一个接口或抽象类来定义要创建的对象类型。 创建具体的类来实现这个接口或抽象类。 创建一个工厂类，它包含一个方法，根据条件创建并返回合适的对象。 在客户端代码中使用工厂类来创建对象，而不是直接使用构造函数。 优点：\n降低了代码的耦合度，使代码更容易维护和扩展。 隐藏了对象的创建细节，使代码更具灵活性。 可以根据需要扩展工厂类以创建新的对象类型。 缺点：\n需要额外的类和接口，增加了代码复杂性。 如果不小心滥用工厂模式，可能会导致过多的工厂类，使代码变得复杂。 抽象工厂模式 抽象工厂模式是一种设计模式，用于创建一组相关或相互依赖的对象，而无需指定其具体类。它提供了一种方法来创建一整套对象，而不仅仅是单个对象。\n解决的问题：\n抽象工厂模式解决了需要创建一组相关对象，如不同品牌的手机或不同类型的家具，而无需关心每个对象的具体类的问题。它使得对象之间的关联和创建过程更加灵活。\n现实中的例子：\n想象你正在开发一个电子设备的制造系统。你需要生产电视、音响和遥控器，同时要确保它们之间能够兼容。抽象工厂模式可以用来创建不同品牌的电视、音响和遥控器，以确保它们协同工作。\nJava 示例代码：\n// 创建抽象工厂接口 interface ElectronicFactory { TV createTV(); Audio createAudio(); Remote createRemote(); } // 创建具体工厂类来实现接口，以生产一组相关产品 class SonyFactory implements ElectronicFactory { @Override public TV createTV() { return new SonyTV(); } @Override public Audio createAudio() { return new SonyAudio(); } @Override public Remote createRemote() { return new SonyRemote(); } } // 创建具体产品类 interface TV { void display(); } class SonyTV implements TV { @Override public void display() { System.out.println(\"Sony TV is displaying.\"); } } // 类似地，创建其他产品类（Audio 和 Remote） // 在客户端代码中，使用工厂来创建一组相关产品 public class Client { public static void main(String[] args) { ElectronicFactory factory = new SonyFactory(); TV tv = factory.createTV(); Audio audio = factory.createAudio(); Remote remote = factory.createRemote(); // 使用这些产品 tv.display(); audio.play(); remote.control(); } } 适用场景：\n当需要创建一组相关对象，如不同品牌的产品系列时。 当希望确保对象之间的兼容性和一致性时。 如何实现：\n创建一个抽象工厂接口，其中包含创建一组相关对象的方法。 创建具体工厂类，实现抽象工厂接口，用于生产特定品牌或类型的产品。 创建产品接口或抽象类，以定义相关产品的共同行为。 创建具体产品类，实现产品接口，以提供不同品牌或类型的产品。 在客户端代码中，使用具体工厂来创建一组相关产品。 优缺点：\n优点：\n提供了一种创建一组相关对象的方法，确保它们之间的兼容性。 客户端代码与具体产品的类名解耦，更容易切换不同品牌或类型的产品。 缺点：\n增加新的产品系列可能需要修改工厂接口和所有具体工厂类，导致代码的复杂性增加。 不适用于单个产品的创建，通常更适合于创建一组相关产品。 扩展内容：\n抽象工厂模式与工厂方法模式有一些相似之处，但抽象工厂模式关注一组相关产品的创建，而工厂方法模式关注单个产品的创建。理解这两种模式之间的区别对于正确选择设计模式非常重要。\n单例模式 什么是单例模式？\n单例模式是一种设计模式，它确保一个类只有一个实例，并提供全局访问点以获取该实例。这意味着无论何时尝试创建该类的新对象，都会返回同一个已存在的实例。\n解决的问题：\n单例模式主要解决了以下问题：\n全局访问：允许在程序中的任何地方轻松访问特定对象的唯一实例。 资源共享：确保多个部分或对象共享相同的资源，例如配置信息、数据库连接或日志记录。 避免重复创建：避免多次创建相同对象，减少内存和性能开销。 现实中的例子：\n打印机驱动程序：计算机只需一个打印机驱动程序实例，以确保所有打印任务都共享相同的驱动程序设置。 日志记录器：单例模式可用于创建一个全局的日志记录器，以便整个应用程序都可以记录日志到同一个文件。 Java 示例代码：\npublic class Singleton { private static Singleton instance; private Singleton() { // 私有构造函数，防止外部实例化 } public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 适用场景：\n单例模式适用于以下情况：\n当需要确保一个类只有一个实例时。 当希望全局访问某个对象，以便多个部分能够共享它。 当需要管理共享资源，例如线程池、数据库连接池等。 优点：\n确保了只有一个实例存在，减少了内存和性能开销。 提供了全局访问点，使对象容易共享和访问。 缺点：\n违反了单一职责原则，因为该类既负责自身的功能，又负责管理自己的生命周期。 可能引发多线程问题，需要进行额外的同步处理，以确保线程安全。 单例模式的实现方式多种多样，不同情况下选择合适的方式很重要。 实现方式：\n饿汉式（Eager Initialization）：\n在这种方式下，单例实例在类加载时就创建好，因此在应用程序运行期间始终存在。这种方式的优点是线程安全，但可能会浪费内存，因为实例在加载类时就创建好了，无论是否需要。\npublic class Singleton { private static final Singleton instance = new Singleton(); private Singleton() { // 私有构造方法 } public static Singleton getInstance() { return instance; } } 懒汉式（Lazy Initialization）：\n这种方式下，单例实例在第一次被访问时才被创建。这种方式可能存在线程安全问题，需要通过同步来解决。\npublic class Singleton { private static Singleton instance; private Singleton() { // 私有构造方法 } public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 双重检查锁定（Double-Check Locking）：\n这种方式在懒汉式的基础上做了改进，通过双重检查来减小锁的开销，提高性能。\npublic class Singleton { private static volatile Singleton instance; // 使用volatile关键字确保可见性，即使在多线程环境中，一个线程修改了instance的值，其他线程也能够立即看到这个修改。 private Singleton() { // 私有构造方法 } public static Singleton getInstance() { if (instance == null) { // 第一次检查 synchronized (Singleton.class) { // 进入同步块（synchronized (Singleton.class)）。这个同步块在多线程环境中确保只有一个线程能够进入，从而避免了多个线程同时创建实例。 if (instance == null) { // 第二次检查 instance = new Singleton(); } } } return instance; } } 静态内部类（Static Inner Class）：\n这种方式使用了静态内部类的特性，在内部类加载时创建单例实例，从而实现懒加载且线程安全。\npublic class Singleton { private Singleton() { // 私有构造方法 } private static class SingletonHolder { private static final Singleton instance = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.instance; } } 枚举（Enum）：\n使用枚举实现单例模式是最简单且线程安全的方式，因为枚举类型的实例是在加载时候初始化的，而且不会有多个实例。\npublic enum Singleton { INSTANCE; public void someMethod() { // 单例方法 } } 代理模式 适配器模式 ","wordCount":"577","inLanguage":"en","datePublished":"2023-10-22T22:28:22+08:00","dateModified":"2023-10-22T22:28:22+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheneydev.github.io/posts/2023-10-21-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"Cheney's blog","logo":{"@type":"ImageObject","url":"https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cheneydev.github.io/ accesskey=h title="Cheney's blog (Alt + H)"><img src=https://cheneydev.github.io/apple-touch-icon.png alt aria-label=logo height=35>Cheney's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cheneydev.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cheneydev.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cheneydev.github.io/posts/>Posts</a></div><h1 class=post-title>设计模式学习笔记</h1><div class=post-meta>&lt;span title='2023-10-22 22:28:22 +0800 CST'>October 22, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;3 min&amp;nbsp;·&amp;nbsp;577 words&amp;nbsp;·&amp;nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/2023-10-21-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=七大原则>七大原则<a hidden class=anchor aria-hidden=true href=#七大原则>#</a></h2><p>设计模式中的七大原则是指的是一组指导性原则，它们帮助开发人员编写更可维护、可扩展、可重用和可理解的代码。这些原则有助于创建高质量的软件设计。</p><table><thead><tr><th>类别</th><th>原则名称</th><th>描述</th></tr></thead><tbody><tr><td>创建类</td><td>单一职责原则 (Single Responsibility Principle )</td><td>一个类应该只有一个引起变化的原因，即一个类应该只有一个单一的责任。</td></tr><tr><td></td><td>开放封闭原则 (Open/Closed Principle)</td><td>软件实体应该是开放于扩展的，但封闭于修改的，可以通过添加新功能来扩展系统，而不需要修改已存在的代码。</td></tr><tr><td>类关系</td><td>里氏替换原则 (Liskov Substitution Principle )</td><td>子类必须能够替换其基类而不引起不良的行为，子类应该保持对基类的兼容性，不应该破坏父类的预期行为。</td></tr><tr><td></td><td>依赖倒置原则 (Dependency Inversion Principle)</td><td>高层模块不应该依赖于低层模块，二者都应该依赖于抽象/接口，抽象/接口不应该依赖于具体细节，具体细节应该依赖于抽象/接口。</td></tr><tr><td></td><td>接口隔离原则 (Interface Segregation Principle )</td><td>客户端不应该被迫依赖于它们不使用的接口，接口应该被细分，使得客户端只需知道与其相关的接口。</td></tr><tr><td>组件复用</td><td>迪米特法则 (Law of Demeter)</td><td>每个单元应该只与其紧密相关的少数其他单元进行交互，减少模块之间的耦合性，使系统更加灵活和易于维护。</td></tr><tr><td></td><td>合成/聚合复用原则 (Composite/Aggregate Reuse Principle)</td><td>尽量使用合成/聚合关系来实现代码重用，而不是继承，降低类之间的耦合性，使系统更灵活。</td></tr></tbody></table><h2 id=常见设计模式>常见设计模式<a hidden class=anchor aria-hidden=true href=#常见设计模式>#</a></h2><table><thead><tr><th>类别</th><th>模式名称</th><th>描述</th></tr></thead><tbody><tr><td>行为型模式</td><td>观察者模式 (Observer Pattern)</td><td>定义了对象之间的一对多依赖关系，使得一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。</td></tr><tr><td></td><td>策略模式 (Strategy Pattern)</td><td>定义一系列算法，将每个算法封装成一个对象，并使它们可以相互替换。客户端可以在运行时选择所需的算法。</td></tr><tr><td></td><td>命令模式 (Command Pattern)</td><td>将请求或操作封装成一个对象，允许将请求参数化、队列化、撤销和重做操作。</td></tr><tr><td></td><td>模板方法模式 (Template Method Pattern)</td><td>定义一个算法的骨架，将一些步骤延迟到子类实现，以便在不改变算法结构的情况下重定义特定步骤。</td></tr><tr><td>结构型模式</td><td>适配器模式 (Adapter Pattern)</td><td>允许将一个类的接口转换成另一个类的接口，使不兼容的接口能够一起工作。</td></tr><tr><td></td><td>装饰器模式 (Decorator Pattern)</td><td>允许动态地将责任附加到对象，扩展对象的功能而不影响其他对象。</td></tr><tr><td></td><td>组合模式 (Composite Pattern)</td><td>允许将对象组合成树形结构以表示部分-整体层次结构。客户端可以统一处理单个对象和组合对象。</td></tr><tr><td></td><td>代理模式 (Proxy Pattern)</td><td>提供了一个代理对象，控制对另一个对象的访问，允许在访问实际对象前后执行额外的操作。</td></tr><tr><td>创建型模式</td><td>工厂方法模式 (Factory Method Pattern)</td><td>定义一个创建对象的接口，但将具体的实例化推迟到子类，以便子类决定要实例化的具体类。</td></tr><tr><td></td><td>抽象工厂模式 (Abstract Factory Pattern)</td><td>提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。</td></tr><tr><td></td><td>单例模式 (Singleton Pattern)</td><td>保证一个类只有一个实例，并提供全局访问点。</td></tr><tr><td></td><td>建造者模式 (Builder Pattern)</td><td>将一个复杂对象的构建过程分离成多个步骤，允许相同的构建过程创建不同的表示。</td></tr><tr><td></td><td>原型模式 (Prototype Pattern)</td><td>允许通过复制现有对象来创建新对象，通常用于创建代价高昂的对象。</td></tr></tbody></table><h2 id=工厂>工厂<a hidden class=anchor aria-hidden=true href=#工厂>#</a></h2><h3 id=工厂方法模式>工厂方法模式<a hidden class=anchor aria-hidden=true href=#工厂方法模式>#</a></h3><p>工厂模式是一种常见的设计模式，用于创建对象。它提供了一种方式来创建对象，而不需要在代码中直接使用构造函数，这有助于解耦代码，提高可维护性和可扩展性。</p><p><strong>解决的问题：</strong></p><p>工厂模式解决了对象的创建过程与其使用的代码之间的耦合问题。它可以隐藏对象的创建细节，使代码更加灵活，降低了代码的复杂性。</p><p><strong>现实中的例子：</strong></p><p>想象一家汽车工厂，它生产各种类型的汽车，如轿车、卡车、SUV等。客户只需要告诉工厂他们需要哪种类型的汽车，而不必亲自制造汽车。工厂会负责创建适当类型的汽车并将其交付给客户。</p><p><strong>Java 示例代码：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 创建一个接口或抽象类，表示要创建的对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>interface</span> <span class=nc>Vehicle</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>drive</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 创建具体的汽车类</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Car</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Vehicle</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>drive</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Driving a car.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Truck</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Vehicle</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>drive</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Driving a truck.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 创建一个工厂类来生产汽车</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>VehicleFactory</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Vehicle</span><span class=w> </span><span class=nf>createVehicle</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>type</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=s>&#34;car&#34;</span><span class=p>.</span><span class=na>equalsIgnoreCase</span><span class=p>(</span><span class=n>type</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Car</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=s>&#34;truck&#34;</span><span class=p>.</span><span class=na>equalsIgnoreCase</span><span class=p>(</span><span class=n>type</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Truck</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>适用场景：</strong></p><ul><li>当对象的创建过程比较复杂，需要隐藏细节时。</li><li>当需要根据条件动态选择创建对象的类型时。</li><li>当希望减少代码中的直接构造函数调用。</li></ul><p><strong>如何实现：</strong></p><ol><li>创建一个接口或抽象类来定义要创建的对象类型。</li><li>创建具体的类来实现这个接口或抽象类。</li><li>创建一个工厂类，它包含一个方法，根据条件创建并返回合适的对象。</li><li>在客户端代码中使用工厂类来创建对象，而不是直接使用构造函数。</li></ol><p><strong>优点：</strong></p><ul><li>降低了代码的耦合度，使代码更容易维护和扩展。</li><li>隐藏了对象的创建细节，使代码更具灵活性。</li><li>可以根据需要扩展工厂类以创建新的对象类型。</li></ul><p><strong>缺点：</strong></p><ul><li>需要额外的类和接口，增加了代码复杂性。</li><li>如果不小心滥用工厂模式，可能会导致过多的工厂类，使代码变得复杂。</li></ul><h3 id=抽象工厂模式>抽象工厂模式<a hidden class=anchor aria-hidden=true href=#抽象工厂模式>#</a></h3><p>抽象工厂模式是一种设计模式，用于创建一组相关或相互依赖的对象，而无需指定其具体类。它提供了一种方法来创建一整套对象，而不仅仅是单个对象。</p><p><strong>解决的问题：</strong></p><p>抽象工厂模式解决了需要创建一组相关对象，如不同品牌的手机或不同类型的家具，而无需关心每个对象的具体类的问题。它使得对象之间的关联和创建过程更加灵活。</p><p><strong>现实中的例子：</strong></p><p>想象你正在开发一个电子设备的制造系统。你需要生产电视、音响和遥控器，同时要确保它们之间能够兼容。抽象工厂模式可以用来创建不同品牌的电视、音响和遥控器，以确保它们协同工作。</p><p><strong>Java 示例代码：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 创建抽象工厂接口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>interface</span> <span class=nc>ElectronicFactory</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TV</span><span class=w> </span><span class=nf>createTV</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Audio</span><span class=w> </span><span class=nf>createAudio</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Remote</span><span class=w> </span><span class=nf>createRemote</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 创建具体工厂类来实现接口，以生产一组相关产品</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>SonyFactory</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>ElectronicFactory</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>TV</span><span class=w> </span><span class=nf>createTV</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>SonyTV</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Audio</span><span class=w> </span><span class=nf>createAudio</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>SonyAudio</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Remote</span><span class=w> </span><span class=nf>createRemote</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>SonyRemote</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 创建具体产品类</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>interface</span> <span class=nc>TV</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>display</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>SonyTV</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>TV</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>display</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Sony TV is displaying.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 类似地，创建其他产品类（Audio 和 Remote）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 在客户端代码中，使用工厂来创建一组相关产品</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Client</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ElectronicFactory</span><span class=w> </span><span class=n>factory</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>SonyFactory</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>TV</span><span class=w> </span><span class=n>tv</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>factory</span><span class=p>.</span><span class=na>createTV</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Audio</span><span class=w> </span><span class=n>audio</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>factory</span><span class=p>.</span><span class=na>createAudio</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Remote</span><span class=w> </span><span class=n>remote</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>factory</span><span class=p>.</span><span class=na>createRemote</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 使用这些产品</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tv</span><span class=p>.</span><span class=na>display</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>audio</span><span class=p>.</span><span class=na>play</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>remote</span><span class=p>.</span><span class=na>control</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>适用场景：</strong></p><ul><li>当需要创建一组相关对象，如不同品牌的产品系列时。</li><li>当希望确保对象之间的兼容性和一致性时。</li></ul><p><strong>如何实现：</strong></p><ol><li>创建一个抽象工厂接口，其中包含创建一组相关对象的方法。</li><li>创建具体工厂类，实现抽象工厂接口，用于生产特定品牌或类型的产品。</li><li>创建产品接口或抽象类，以定义相关产品的共同行为。</li><li>创建具体产品类，实现产品接口，以提供不同品牌或类型的产品。</li><li>在客户端代码中，使用具体工厂来创建一组相关产品。</li></ol><p><strong>优缺点：</strong></p><p><strong>优点：</strong></p><ul><li>提供了一种创建一组相关对象的方法，确保它们之间的兼容性。</li><li>客户端代码与具体产品的类名解耦，更容易切换不同品牌或类型的产品。</li></ul><p><strong>缺点：</strong></p><ul><li>增加新的产品系列可能需要修改工厂接口和所有具体工厂类，导致代码的复杂性增加。</li><li>不适用于单个产品的创建，通常更适合于创建一组相关产品。</li></ul><p><strong>扩展内容：</strong></p><p>抽象工厂模式与工厂方法模式有一些相似之处，但抽象工厂模式关注一组相关产品的创建，而工厂方法模式关注单个产品的创建。理解这两种模式之间的区别对于正确选择设计模式非常重要。</p><h2 id=单例模式>单例模式<a hidden class=anchor aria-hidden=true href=#单例模式>#</a></h2><p><strong>什么是单例模式？</strong></p><p>单例模式是一种设计模式，它确保一个类只有一个实例，并提供全局访问点以获取该实例。这意味着无论何时尝试创建该类的新对象，都会返回同一个已存在的实例。</p><p><strong>解决的问题：</strong></p><p>单例模式主要解决了以下问题：</p><ol><li><strong>全局访问</strong>：允许在程序中的任何地方轻松访问特定对象的唯一实例。</li><li><strong>资源共享</strong>：确保多个部分或对象共享相同的资源，例如配置信息、数据库连接或日志记录。</li><li><strong>避免重复创建</strong>：避免多次创建相同对象，减少内存和性能开销。</li></ol><p><strong>现实中的例子：</strong></p><ul><li><strong>打印机驱动程序</strong>：计算机只需一个打印机驱动程序实例，以确保所有打印任务都共享相同的驱动程序设置。</li><li><strong>日志记录器</strong>：单例模式可用于创建一个全局的日志记录器，以便整个应用程序都可以记录日志到同一个文件。</li></ul><p><strong>Java 示例代码：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Singleton</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=nf>Singleton</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 私有构造函数，防止外部实例化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=nf>getInstance</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>instance</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>instance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Singleton</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>适用场景：</strong></p><p>单例模式适用于以下情况：</p><ul><li>当需要确保一个类只有一个实例时。</li><li>当希望全局访问某个对象，以便多个部分能够共享它。</li><li>当需要管理共享资源，例如线程池、数据库连接池等。</li></ul><p><strong>优点</strong>：</p><ul><li>确保了只有一个实例存在，减少了内存和性能开销。</li><li>提供了全局访问点，使对象容易共享和访问。</li></ul><p><strong>缺点</strong>：</p><ul><li>违反了单一职责原则，因为该类既负责自身的功能，又负责管理自己的生命周期。</li><li>可能引发多线程问题，需要进行额外的同步处理，以确保线程安全。</li><li>单例模式的实现方式多种多样，不同情况下选择合适的方式很重要。</li></ul><p><strong>实现方式：</strong></p><ol><li><p>饿汉式（Eager Initialization）：</p><p>在这种方式下，单例实例在类加载时就创建好，因此在应用程序运行期间始终存在。这种方式的优点是线程安全，但可能会浪费内存，因为实例在加载类时就创建好了，无论是否需要。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Singleton</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=n>instance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Singleton</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=nf>Singleton</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 私有构造方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=nf>getInstance</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p>懒汉式（Lazy Initialization）：</p><p>这种方式下，单例实例在第一次被访问时才被创建。这种方式可能存在线程安全问题，需要通过同步来解决。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Singleton</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=nf>Singleton</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 私有构造方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>synchronized</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=nf>getInstance</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>instance</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>instance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Singleton</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p>双重检查锁定（Double-Check Locking）：</p><p>这种方式在懒汉式的基础上做了改进，通过双重检查来减小锁的开销，提高性能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Singleton</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>volatile</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w> </span><span class=c1>// 使用volatile关键字确保可见性，即使在多线程环境中，一个线程修改了instance的值，其他线程也能够立即看到这个修改。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=nf>Singleton</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 私有构造方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=nf>getInstance</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>instance</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// 第一次检查</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>synchronized</span><span class=w> </span><span class=p>(</span><span class=n>Singleton</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// 进入同步块（synchronized (Singleton.class)）。这个同步块在多线程环境中确保只有一个线程能够进入，从而避免了多个线程同时创建实例。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>instance</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// 第二次检查</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>instance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Singleton</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p>静态内部类（Static Inner Class）：</p><p>这种方式使用了静态内部类的特性，在内部类加载时创建单例实例，从而实现懒加载且线程安全。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Singleton</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=nf>Singleton</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 私有构造方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>class</span> <span class=nc>SingletonHolder</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=n>instance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Singleton</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=nf>getInstance</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>SingletonHolder</span><span class=p>.</span><span class=na>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p>枚举（Enum）：</p><p>使用枚举实现单例模式是最简单且线程安全的方式，因为枚举类型的实例是在加载时候初始化的，而且不会有多个实例。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>enum</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>INSTANCE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>someMethod</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 单例方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ol><h2 id=代理模式>代理模式<a hidden class=anchor aria-hidden=true href=#代理模式>#</a></h2><h2 id=适配器模式>适配器模式<a hidden class=anchor aria-hidden=true href=#适配器模式>#</a></h2></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://cheneydev.github.io/posts/2023-10-21-chatgpt-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/><span class=title>« Prev</span><br><span>ChatGPT 提示工程</span>
</a><a class=next href=https://cheneydev.github.io/posts/2023-10-14-mysql-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><span class=title>Next »</span><br><span>MySQL 学习笔记</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 设计模式学习笔记 on twitter" href="https://twitter.com/intent/tweet/?text=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 设计模式学习笔记 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;title=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&amp;summary=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&amp;source=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 设计模式学习笔记 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f&title=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 设计模式学习笔记 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 设计模式学习笔记 on whatsapp" href="https://api.whatsapp.com/send?text=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%20-%20https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 设计模式学习笔记 on telegram" href="https://telegram.me/share/url?text=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://cheneydev.github.io/>Cheney's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>