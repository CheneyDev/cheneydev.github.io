<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>设计模式学习笔记 | Cheney's blog</title><meta name=keywords content><meta name=description content="七大原则 设计模式中的七大原则是指的是一组指导性原则，它们帮助开发人员编写更可维护、可扩展、可重用和可理解的代码。这些原则有助于创建高质量的软件设计。
类别 原则名称 描述 创建类 单一职责原则 (Single Responsibility Principle ) 一个类应该只有一个引起变化的原因，即一个类应该只有一个单一的责任。 开放封闭原则 (Open/Closed Principle) 软件实体应该是开放于扩展的，但封闭于修改的，可以通过添加新功能来扩展系统，而不需要修改已存在的代码。 类关系 里氏替换原则 (Liskov Substitution Principle ) 子类必须能够替换其基类而不引起不良的行为，子类应该保持对基类的兼容性，不应该破坏父类的预期行为。 依赖倒置原则 (Dependency Inversion Principle) 高层模块不应该依赖于低层模块，二者都应该依赖于抽象/接口，抽象/接口不应该依赖于具体细节，具体细节应该依赖于抽象/接口。 接口隔离原则 (Interface Segregation Principle ) 客户端不应该被迫依赖于它们不使用的接口，接口应该被细分，使得客户端只需知道与其相关的接口。 组件复用 迪米特法则 (Law of Demeter) 每个单元应该只与其紧密相关的少数其他单元进行交互，减少模块之间的耦合性，使系统更加灵活和易于维护。 合成/聚合复用原则 (Composite/Aggregate Reuse Principle) 尽量使用合成/聚合关系来实现代码重用，而不是继承，降低类之间的耦合性，使系统更灵活。 常见设计模式 类别 模式名称 描述 行为型模式 观察者模式 (Observer Pattern) 定义了对象之间的一对多依赖关系，使得一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。 策略模式 (Strategy Pattern) 定义一系列算法，将每个算法封装成一个对象，并使它们可以相互替换。客户端可以在运行时选择所需的算法。 命令模式 (Command Pattern) 将请求或操作封装成一个对象，允许将请求参数化、队列化、撤销和重做操作。 模板方法模式 (Template Method Pattern) 定义一个算法的骨架，将一些步骤延迟到子类实现，以便在不改变算法结构的情况下重定义特定步骤。 结构型模式 适配器模式 (Adapter Pattern) 允许将一个类的接口转换成另一个类的接口，使不兼容的接口能够一起工作。 装饰器模式 (Decorator Pattern) 允许动态地将责任附加到对象，扩展对象的功能而不影响其他对象。 组合模式 (Composite Pattern) 允许将对象组合成树形结构以表示部分-整体层次结构。客户端可以统一处理单个对象和组合对象。 代理模式 (Proxy Pattern) 提供了一个代理对象，控制对另一个对象的访问，允许在访问实际对象前后执行额外的操作。 创建型模式 工厂方法模式 (Factory Method Pattern) 定义一个创建对象的接口，但将具体的实例化推迟到子类，以便子类决定要实例化的具体类。 抽象工厂模式 (Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。 单例模式 (Singleton Pattern) 保证一个类只有一个实例，并提供全局访问点。 建造者模式 (Builder Pattern) 将一个复杂对象的构建过程分离成多个步骤，允许相同的构建过程创建不同的表示。 原型模式 (Prototype Pattern) 允许通过复制现有对象来创建新对象，通常用于创建代价高昂的对象。 抽象工厂模式（Abstract Factory Pattern） 介绍 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它允许你定义一组相关对象的创建接口，每个具体工厂负责创建一组相关产品。这有助于将对象创建过程与客户端代码解耦，支持创建不同产品家族，并提供高内聚和低耦合的代码结构。"><meta name=author content="Me"><link rel=canonical href=https://cheneydev.github.io/posts/2023-10-21-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="设计模式学习笔记"><meta property="og:description" content="七大原则 设计模式中的七大原则是指的是一组指导性原则，它们帮助开发人员编写更可维护、可扩展、可重用和可理解的代码。这些原则有助于创建高质量的软件设计。
类别 原则名称 描述 创建类 单一职责原则 (Single Responsibility Principle ) 一个类应该只有一个引起变化的原因，即一个类应该只有一个单一的责任。 开放封闭原则 (Open/Closed Principle) 软件实体应该是开放于扩展的，但封闭于修改的，可以通过添加新功能来扩展系统，而不需要修改已存在的代码。 类关系 里氏替换原则 (Liskov Substitution Principle ) 子类必须能够替换其基类而不引起不良的行为，子类应该保持对基类的兼容性，不应该破坏父类的预期行为。 依赖倒置原则 (Dependency Inversion Principle) 高层模块不应该依赖于低层模块，二者都应该依赖于抽象/接口，抽象/接口不应该依赖于具体细节，具体细节应该依赖于抽象/接口。 接口隔离原则 (Interface Segregation Principle ) 客户端不应该被迫依赖于它们不使用的接口，接口应该被细分，使得客户端只需知道与其相关的接口。 组件复用 迪米特法则 (Law of Demeter) 每个单元应该只与其紧密相关的少数其他单元进行交互，减少模块之间的耦合性，使系统更加灵活和易于维护。 合成/聚合复用原则 (Composite/Aggregate Reuse Principle) 尽量使用合成/聚合关系来实现代码重用，而不是继承，降低类之间的耦合性，使系统更灵活。 常见设计模式 类别 模式名称 描述 行为型模式 观察者模式 (Observer Pattern) 定义了对象之间的一对多依赖关系，使得一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。 策略模式 (Strategy Pattern) 定义一系列算法，将每个算法封装成一个对象，并使它们可以相互替换。客户端可以在运行时选择所需的算法。 命令模式 (Command Pattern) 将请求或操作封装成一个对象，允许将请求参数化、队列化、撤销和重做操作。 模板方法模式 (Template Method Pattern) 定义一个算法的骨架，将一些步骤延迟到子类实现，以便在不改变算法结构的情况下重定义特定步骤。 结构型模式 适配器模式 (Adapter Pattern) 允许将一个类的接口转换成另一个类的接口，使不兼容的接口能够一起工作。 装饰器模式 (Decorator Pattern) 允许动态地将责任附加到对象，扩展对象的功能而不影响其他对象。 组合模式 (Composite Pattern) 允许将对象组合成树形结构以表示部分-整体层次结构。客户端可以统一处理单个对象和组合对象。 代理模式 (Proxy Pattern) 提供了一个代理对象，控制对另一个对象的访问，允许在访问实际对象前后执行额外的操作。 创建型模式 工厂方法模式 (Factory Method Pattern) 定义一个创建对象的接口，但将具体的实例化推迟到子类，以便子类决定要实例化的具体类。 抽象工厂模式 (Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。 单例模式 (Singleton Pattern) 保证一个类只有一个实例，并提供全局访问点。 建造者模式 (Builder Pattern) 将一个复杂对象的构建过程分离成多个步骤，允许相同的构建过程创建不同的表示。 原型模式 (Prototype Pattern) 允许通过复制现有对象来创建新对象，通常用于创建代价高昂的对象。 抽象工厂模式（Abstract Factory Pattern） 介绍 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它允许你定义一组相关对象的创建接口，每个具体工厂负责创建一组相关产品。这有助于将对象创建过程与客户端代码解耦，支持创建不同产品家族，并提供高内聚和低耦合的代码结构。"><meta property="og:type" content="article"><meta property="og:url" content="https://cheneydev.github.io/posts/2023-10-21-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:image" content="https://cheneydev.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-22T22:28:22+08:00"><meta property="article:modified_time" content="2023-10-22T22:28:22+08:00"><meta property="og:site_name" content="Cheney Wang"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cheneydev.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="设计模式学习笔记"><meta name=twitter:description content="七大原则 设计模式中的七大原则是指的是一组指导性原则，它们帮助开发人员编写更可维护、可扩展、可重用和可理解的代码。这些原则有助于创建高质量的软件设计。
类别 原则名称 描述 创建类 单一职责原则 (Single Responsibility Principle ) 一个类应该只有一个引起变化的原因，即一个类应该只有一个单一的责任。 开放封闭原则 (Open/Closed Principle) 软件实体应该是开放于扩展的，但封闭于修改的，可以通过添加新功能来扩展系统，而不需要修改已存在的代码。 类关系 里氏替换原则 (Liskov Substitution Principle ) 子类必须能够替换其基类而不引起不良的行为，子类应该保持对基类的兼容性，不应该破坏父类的预期行为。 依赖倒置原则 (Dependency Inversion Principle) 高层模块不应该依赖于低层模块，二者都应该依赖于抽象/接口，抽象/接口不应该依赖于具体细节，具体细节应该依赖于抽象/接口。 接口隔离原则 (Interface Segregation Principle ) 客户端不应该被迫依赖于它们不使用的接口，接口应该被细分，使得客户端只需知道与其相关的接口。 组件复用 迪米特法则 (Law of Demeter) 每个单元应该只与其紧密相关的少数其他单元进行交互，减少模块之间的耦合性，使系统更加灵活和易于维护。 合成/聚合复用原则 (Composite/Aggregate Reuse Principle) 尽量使用合成/聚合关系来实现代码重用，而不是继承，降低类之间的耦合性，使系统更灵活。 常见设计模式 类别 模式名称 描述 行为型模式 观察者模式 (Observer Pattern) 定义了对象之间的一对多依赖关系，使得一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。 策略模式 (Strategy Pattern) 定义一系列算法，将每个算法封装成一个对象，并使它们可以相互替换。客户端可以在运行时选择所需的算法。 命令模式 (Command Pattern) 将请求或操作封装成一个对象，允许将请求参数化、队列化、撤销和重做操作。 模板方法模式 (Template Method Pattern) 定义一个算法的骨架，将一些步骤延迟到子类实现，以便在不改变算法结构的情况下重定义特定步骤。 结构型模式 适配器模式 (Adapter Pattern) 允许将一个类的接口转换成另一个类的接口，使不兼容的接口能够一起工作。 装饰器模式 (Decorator Pattern) 允许动态地将责任附加到对象，扩展对象的功能而不影响其他对象。 组合模式 (Composite Pattern) 允许将对象组合成树形结构以表示部分-整体层次结构。客户端可以统一处理单个对象和组合对象。 代理模式 (Proxy Pattern) 提供了一个代理对象，控制对另一个对象的访问，允许在访问实际对象前后执行额外的操作。 创建型模式 工厂方法模式 (Factory Method Pattern) 定义一个创建对象的接口，但将具体的实例化推迟到子类，以便子类决定要实例化的具体类。 抽象工厂模式 (Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。 单例模式 (Singleton Pattern) 保证一个类只有一个实例，并提供全局访问点。 建造者模式 (Builder Pattern) 将一个复杂对象的构建过程分离成多个步骤，允许相同的构建过程创建不同的表示。 原型模式 (Prototype Pattern) 允许通过复制现有对象来创建新对象，通常用于创建代价高昂的对象。 抽象工厂模式（Abstract Factory Pattern） 介绍 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它允许你定义一组相关对象的创建接口，每个具体工厂负责创建一组相关产品。这有助于将对象创建过程与客户端代码解耦，支持创建不同产品家族，并提供高内聚和低耦合的代码结构。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cheneydev.github.io/posts/"},{"@type":"ListItem","position":2,"name":"设计模式学习笔记","item":"https://cheneydev.github.io/posts/2023-10-21-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"设计模式学习笔记","name":"设计模式学习笔记","description":"七大原则 设计模式中的七大原则是指的是一组指导性原则，它们帮助开发人员编写更可维护、可扩展、可重用和可理解的代码。这些原则有助于创建高质量的软件设计。\n类别 原则名称 描述 创建类 单一职责原则 (Single Responsibility Principle ) 一个类应该只有一个引起变化的原因，即一个类应该只有一个单一的责任。 开放封闭原则 (Open/Closed Principle) 软件实体应该是开放于扩展的，但封闭于修改的，可以通过添加新功能来扩展系统，而不需要修改已存在的代码。 类关系 里氏替换原则 (Liskov Substitution Principle ) 子类必须能够替换其基类而不引起不良的行为，子类应该保持对基类的兼容性，不应该破坏父类的预期行为。 依赖倒置原则 (Dependency Inversion Principle) 高层模块不应该依赖于低层模块，二者都应该依赖于抽象/接口，抽象/接口不应该依赖于具体细节，具体细节应该依赖于抽象/接口。 接口隔离原则 (Interface Segregation Principle ) 客户端不应该被迫依赖于它们不使用的接口，接口应该被细分，使得客户端只需知道与其相关的接口。 组件复用 迪米特法则 (Law of Demeter) 每个单元应该只与其紧密相关的少数其他单元进行交互，减少模块之间的耦合性，使系统更加灵活和易于维护。 合成/聚合复用原则 (Composite/Aggregate Reuse Principle) 尽量使用合成/聚合关系来实现代码重用，而不是继承，降低类之间的耦合性，使系统更灵活。 常见设计模式 类别 模式名称 描述 行为型模式 观察者模式 (Observer Pattern) 定义了对象之间的一对多依赖关系，使得一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。 策略模式 (Strategy Pattern) 定义一系列算法，将每个算法封装成一个对象，并使它们可以相互替换。客户端可以在运行时选择所需的算法。 命令模式 (Command Pattern) 将请求或操作封装成一个对象，允许将请求参数化、队列化、撤销和重做操作。 模板方法模式 (Template Method Pattern) 定义一个算法的骨架，将一些步骤延迟到子类实现，以便在不改变算法结构的情况下重定义特定步骤。 结构型模式 适配器模式 (Adapter Pattern) 允许将一个类的接口转换成另一个类的接口，使不兼容的接口能够一起工作。 装饰器模式 (Decorator Pattern) 允许动态地将责任附加到对象，扩展对象的功能而不影响其他对象。 组合模式 (Composite Pattern) 允许将对象组合成树形结构以表示部分-整体层次结构。客户端可以统一处理单个对象和组合对象。 代理模式 (Proxy Pattern) 提供了一个代理对象，控制对另一个对象的访问，允许在访问实际对象前后执行额外的操作。 创建型模式 工厂方法模式 (Factory Method Pattern) 定义一个创建对象的接口，但将具体的实例化推迟到子类，以便子类决定要实例化的具体类。 抽象工厂模式 (Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。 单例模式 (Singleton Pattern) 保证一个类只有一个实例，并提供全局访问点。 建造者模式 (Builder Pattern) 将一个复杂对象的构建过程分离成多个步骤，允许相同的构建过程创建不同的表示。 原型模式 (Prototype Pattern) 允许通过复制现有对象来创建新对象，通常用于创建代价高昂的对象。 抽象工厂模式（Abstract Factory Pattern） 介绍 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它允许你定义一组相关对象的创建接口，每个具体工厂负责创建一组相关产品。这有助于将对象创建过程与客户端代码解耦，支持创建不同产品家族，并提供高内聚和低耦合的代码结构。","keywords":[],"articleBody":"七大原则 设计模式中的七大原则是指的是一组指导性原则，它们帮助开发人员编写更可维护、可扩展、可重用和可理解的代码。这些原则有助于创建高质量的软件设计。\n类别 原则名称 描述 创建类 单一职责原则 (Single Responsibility Principle ) 一个类应该只有一个引起变化的原因，即一个类应该只有一个单一的责任。 开放封闭原则 (Open/Closed Principle) 软件实体应该是开放于扩展的，但封闭于修改的，可以通过添加新功能来扩展系统，而不需要修改已存在的代码。 类关系 里氏替换原则 (Liskov Substitution Principle ) 子类必须能够替换其基类而不引起不良的行为，子类应该保持对基类的兼容性，不应该破坏父类的预期行为。 依赖倒置原则 (Dependency Inversion Principle) 高层模块不应该依赖于低层模块，二者都应该依赖于抽象/接口，抽象/接口不应该依赖于具体细节，具体细节应该依赖于抽象/接口。 接口隔离原则 (Interface Segregation Principle ) 客户端不应该被迫依赖于它们不使用的接口，接口应该被细分，使得客户端只需知道与其相关的接口。 组件复用 迪米特法则 (Law of Demeter) 每个单元应该只与其紧密相关的少数其他单元进行交互，减少模块之间的耦合性，使系统更加灵活和易于维护。 合成/聚合复用原则 (Composite/Aggregate Reuse Principle) 尽量使用合成/聚合关系来实现代码重用，而不是继承，降低类之间的耦合性，使系统更灵活。 常见设计模式 类别 模式名称 描述 行为型模式 观察者模式 (Observer Pattern) 定义了对象之间的一对多依赖关系，使得一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。 策略模式 (Strategy Pattern) 定义一系列算法，将每个算法封装成一个对象，并使它们可以相互替换。客户端可以在运行时选择所需的算法。 命令模式 (Command Pattern) 将请求或操作封装成一个对象，允许将请求参数化、队列化、撤销和重做操作。 模板方法模式 (Template Method Pattern) 定义一个算法的骨架，将一些步骤延迟到子类实现，以便在不改变算法结构的情况下重定义特定步骤。 结构型模式 适配器模式 (Adapter Pattern) 允许将一个类的接口转换成另一个类的接口，使不兼容的接口能够一起工作。 装饰器模式 (Decorator Pattern) 允许动态地将责任附加到对象，扩展对象的功能而不影响其他对象。 组合模式 (Composite Pattern) 允许将对象组合成树形结构以表示部分-整体层次结构。客户端可以统一处理单个对象和组合对象。 代理模式 (Proxy Pattern) 提供了一个代理对象，控制对另一个对象的访问，允许在访问实际对象前后执行额外的操作。 创建型模式 工厂方法模式 (Factory Method Pattern) 定义一个创建对象的接口，但将具体的实例化推迟到子类，以便子类决定要实例化的具体类。 抽象工厂模式 (Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。 单例模式 (Singleton Pattern) 保证一个类只有一个实例，并提供全局访问点。 建造者模式 (Builder Pattern) 将一个复杂对象的构建过程分离成多个步骤，允许相同的构建过程创建不同的表示。 原型模式 (Prototype Pattern) 允许通过复制现有对象来创建新对象，通常用于创建代价高昂的对象。 抽象工厂模式（Abstract Factory Pattern） 介绍 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它允许你定义一组相关对象的创建接口，每个具体工厂负责创建一组相关产品。这有助于将对象创建过程与客户端代码解耦，支持创建不同产品家族，并提供高内聚和低耦合的代码结构。\n抽象工厂模式就像是一家玩具工厂，这家工厂可以生产各种不同系列的玩具，比如木头系列和塑料系列。\n工厂：这就是我们的工厂，它负责生产各种系列的玩具。 玩具系列：比如木头系列和塑料系列，它们有各自的特点。 具体产品：就像工厂生产的实际玩具，比如木头系列可能生产木头玩具，塑料系列可能生产塑料玩具。 当你需要一种特定系列的玩具时，只需告诉工厂，工厂就会给你生产出这个系列的玩具，而你不需要关心它们是怎么生产的。\n这就是抽象工厂模式的核心思想，它让你能够轻松切换不同系列的产品，而不必关心每个产品是如何制造的。\n以下是抽象工厂模式的关键要点和参与者：\n抽象工厂（Abstract Factory）：定义了一组创建相关对象的方法，这些方法通常以接口或抽象类的形式提供。具体的工厂类将实现这个接口，每个工厂类负责创建一组相关的产品。\n具体工厂（Concrete Factory）：这些工厂类实现了抽象工厂接口，负责实际创建产品对象。每个具体工厂类都会创建一组相关的产品。\n抽象产品（Abstract Product）：定义了一组产品的接口，每个具体产品类都应该实现这个接口。\n具体产品（Concrete Product）：这些是实际的产品类，它们实现了抽象产品接口，由具体工厂类创建。\n抽象工厂模式的主要优点包括：\n高内聚低耦合： 通过将相关对象的创建集中在一个工厂中，抽象工厂模式提供了高内聚性和低耦合性，有助于维护和扩展系统。\n易于替换： 客户端代码可以轻松替换一种具体工厂来切换整个产品家族，而无需修改现有代码。\n遵循开闭原则： 抽象工厂模式支持新产品的添加，而不需要修改现有代码。\n然而，抽象工厂模式也有一些限制：\n复杂性增加： 随着产品家族的增长，抽象工厂模式可能会变得复杂，需要创建多个工厂类和产品类。\n不适用于单个产品的变化： 如果只有一个产品家族的一个部分需要变化，抽象工厂模式可能过于笨重。\n抽象工厂模式在需要创建一组相关对象并希望实现高内聚和低耦合的情况下非常有用。它在构建复杂的系统，如图形用户界面库或数据库驱动程序等方面得到广泛应用。\n示例代码 以下是一个简单的Java示例代码，演示了抽象工厂模式的应用。在这个示例中，我们将创建一个界面工厂，其中包括按钮和文本框的抽象产品以及两个具体的工厂实现：Windows工厂和Mac工厂。每个具体工厂都负责创建相应操作系统风格下的按钮和文本框。\n// 抽象产品：按钮 interface Button { void paint(); } // 具体产品：Windows按钮 class WindowsButton implements Button { @Override public void paint() { System.out.println(\"Render a Windows button\"); } } // 具体产品：Mac按钮 class MacButton implements Button { @Override public void paint() { System.out.println(\"Render a Mac button\"); } } // 抽象产品：文本框 interface TextBox { void display(); } // 具体产品：Windows文本框 class WindowsTextBox implements TextBox { @Override public void display() { System.out.println(\"Display a Windows text box\"); } } // 具体产品：Mac文本框 class MacTextBox implements TextBox { @Override public void display() { System.out.println(\"Display a Mac text box\"); } } // 抽象工厂接口 interface GUIFactory { Button createButton(); TextBox createTextBox(); } // 具体工厂：Windows工厂 class WindowsFactory implements GUIFactory { @Override public Button createButton() { return new WindowsButton(); } @Override public TextBox createTextBox() { return new WindowsTextBox(); } } // 具体工厂：Mac工厂 class MacFactory implements GUIFactory { @Override public Button createButton() { return new MacButton(); } @Override public TextBox createTextBox() { return new MacTextBox(); } } public class AbstractFactoryExample { public static void main(String[] args) { // 创建一个Windows风格的工厂 GUIFactory windowsFactory = new WindowsFactory(); Button windowsButton = windowsFactory.createButton(); TextBox windowsTextBox = windowsFactory.createTextBox(); windowsButton.paint(); windowsTextBox.display(); // 创建一个Mac风格的工厂 GUIFactory macFactory = new MacFactory(); Button macButton = macFactory.createButton(); TextBox macTextBox = macFactory.createTextBox(); macButton.paint(); macTextBox.display(); } } 常见面试题\n什么是抽象工厂模式？ 抽象工厂模式就是使用一个接口，使用这个接口创建一系列相关的对象，而无需指定它们的具体类。这允许客户端代码与具体对象的创建过程解耦，以支持创建不同产品家族。 抽象工厂模式与工厂方法模式有什么不同？ 抽象工厂模式与工厂方法模式的主要区别在于范围。抽象工厂模式创建一整套产品家族，而工厂方法模式只创建一个产品。抽象工厂模式的具体工厂类通常创建多个相关产品，而工厂方法模式的具体工厂类只创建一个产品。 抽象工厂模式的应用场景是什么？ 抽象工厂模式适用于需要创建一组相关对象的情况，如创建跨平台用户界面组件（按钮、文本框等），不同数据库连接的驱动程序，或者不同主题的应用程序皮肤等。 抽象工厂模式的优点和缺点是什么？ 优点包括高内聚、低耦合，支持创建不同产品家族，符合开闭原则。缺点包括增加复杂性，不适用于单个产品变化的情况。 可以举例说明抽象工厂模式在编程中的具体实现吗？ 示例代码见前面的Java示例，其中使用抽象工厂模式创建了不同操作系统下的UI组件。 抽象工厂模式和单例模式之间是否有联系？ 抽象工厂模式和单例模式没有直接联系，但具体工厂类可以是单例，以确保只有一个工厂实例用于创建产品。 抽象工厂模式与其他设计模式的结合使用情况如何？ 抽象工厂模式通常与其他模式如观察者模式、策略模式等结合使用。例如，可以使用策略模式定义不同算法，而抽象工厂模式用于创建特定算法的实例。 什么是抽象产品和具体产品？ 抽象产品是产品的接口或抽象类，它定义了产品的通用行为。具体产品是实际的产品类，它们实现了抽象产品的接口或继承了抽象产品的抽象类，以提供具体的行为。 ","wordCount":"359","inLanguage":"en","datePublished":"2023-10-22T22:28:22+08:00","dateModified":"2023-10-22T22:28:22+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheneydev.github.io/posts/2023-10-21-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"Cheney's blog","logo":{"@type":"ImageObject","url":"https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cheneydev.github.io/ accesskey=h title="Cheney's blog (Alt + H)"><img src=https://cheneydev.github.io/apple-touch-icon.png alt aria-label=logo height=35>Cheney's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cheneydev.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cheneydev.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cheneydev.github.io/posts/>Posts</a></div><h1 class=post-title>设计模式学习笔记</h1><div class=post-meta><span title='2023-10-22 22:28:22 +0800 CST'>October 22, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;359 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/2023-10-21-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=七大原则>七大原则<a hidden class=anchor aria-hidden=true href=#七大原则>#</a></h1><p>设计模式中的七大原则是指的是一组指导性原则，它们帮助开发人员编写更可维护、可扩展、可重用和可理解的代码。这些原则有助于创建高质量的软件设计。</p><table><thead><tr><th>类别</th><th>原则名称</th><th>描述</th></tr></thead><tbody><tr><td>创建类</td><td>单一职责原则 (Single Responsibility Principle )</td><td>一个类应该只有一个引起变化的原因，即一个类应该只有一个单一的责任。</td></tr><tr><td></td><td>开放封闭原则 (Open/Closed Principle)</td><td>软件实体应该是开放于扩展的，但封闭于修改的，可以通过添加新功能来扩展系统，而不需要修改已存在的代码。</td></tr><tr><td>类关系</td><td>里氏替换原则 (Liskov Substitution Principle )</td><td>子类必须能够替换其基类而不引起不良的行为，子类应该保持对基类的兼容性，不应该破坏父类的预期行为。</td></tr><tr><td></td><td>依赖倒置原则 (Dependency Inversion Principle)</td><td>高层模块不应该依赖于低层模块，二者都应该依赖于抽象/接口，抽象/接口不应该依赖于具体细节，具体细节应该依赖于抽象/接口。</td></tr><tr><td></td><td>接口隔离原则 (Interface Segregation Principle )</td><td>客户端不应该被迫依赖于它们不使用的接口，接口应该被细分，使得客户端只需知道与其相关的接口。</td></tr><tr><td>组件复用</td><td>迪米特法则 (Law of Demeter)</td><td>每个单元应该只与其紧密相关的少数其他单元进行交互，减少模块之间的耦合性，使系统更加灵活和易于维护。</td></tr><tr><td></td><td>合成/聚合复用原则 (Composite/Aggregate Reuse Principle)</td><td>尽量使用合成/聚合关系来实现代码重用，而不是继承，降低类之间的耦合性，使系统更灵活。</td></tr></tbody></table><h1 id=常见设计模式>常见设计模式<a hidden class=anchor aria-hidden=true href=#常见设计模式>#</a></h1><table><thead><tr><th>类别</th><th>模式名称</th><th>描述</th></tr></thead><tbody><tr><td>行为型模式</td><td>观察者模式 (Observer Pattern)</td><td>定义了对象之间的一对多依赖关系，使得一个对象的状态发生变化时，其所有依赖对象都会得到通知并自动更新。</td></tr><tr><td></td><td>策略模式 (Strategy Pattern)</td><td>定义一系列算法，将每个算法封装成一个对象，并使它们可以相互替换。客户端可以在运行时选择所需的算法。</td></tr><tr><td></td><td>命令模式 (Command Pattern)</td><td>将请求或操作封装成一个对象，允许将请求参数化、队列化、撤销和重做操作。</td></tr><tr><td></td><td>模板方法模式 (Template Method Pattern)</td><td>定义一个算法的骨架，将一些步骤延迟到子类实现，以便在不改变算法结构的情况下重定义特定步骤。</td></tr><tr><td>结构型模式</td><td>适配器模式 (Adapter Pattern)</td><td>允许将一个类的接口转换成另一个类的接口，使不兼容的接口能够一起工作。</td></tr><tr><td></td><td>装饰器模式 (Decorator Pattern)</td><td>允许动态地将责任附加到对象，扩展对象的功能而不影响其他对象。</td></tr><tr><td></td><td>组合模式 (Composite Pattern)</td><td>允许将对象组合成树形结构以表示部分-整体层次结构。客户端可以统一处理单个对象和组合对象。</td></tr><tr><td></td><td>代理模式 (Proxy Pattern)</td><td>提供了一个代理对象，控制对另一个对象的访问，允许在访问实际对象前后执行额外的操作。</td></tr><tr><td>创建型模式</td><td>工厂方法模式 (Factory Method Pattern)</td><td>定义一个创建对象的接口，但将具体的实例化推迟到子类，以便子类决定要实例化的具体类。</td></tr><tr><td></td><td>抽象工厂模式 (Abstract Factory Pattern)</td><td>提供一个创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。</td></tr><tr><td></td><td>单例模式 (Singleton Pattern)</td><td>保证一个类只有一个实例，并提供全局访问点。</td></tr><tr><td></td><td>建造者模式 (Builder Pattern)</td><td>将一个复杂对象的构建过程分离成多个步骤，允许相同的构建过程创建不同的表示。</td></tr><tr><td></td><td>原型模式 (Prototype Pattern)</td><td>允许通过复制现有对象来创建新对象，通常用于创建代价高昂的对象。</td></tr></tbody></table><h2 id=抽象工厂模式abstract-factory-pattern>抽象工厂模式（Abstract Factory Pattern）<a hidden class=anchor aria-hidden=true href=#抽象工厂模式abstract-factory-pattern>#</a></h2><h3 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h3><p>抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它允许你定义一组相关对象的创建接口，每个具体工厂负责创建一组相关产品。这有助于将对象创建过程与客户端代码解耦，支持创建不同产品家族，并提供高内聚和低耦合的代码结构。</p><p>抽象工厂模式就像是一家玩具工厂，这家工厂可以生产各种不同系列的玩具，比如木头系列和塑料系列。</p><ul><li>工厂：这就是我们的工厂，它负责生产各种系列的玩具。</li><li>玩具系列：比如木头系列和塑料系列，它们有各自的特点。</li><li>具体产品：就像工厂生产的实际玩具，比如木头系列可能生产木头玩具，塑料系列可能生产塑料玩具。</li></ul><p>当你需要一种特定系列的玩具时，只需告诉工厂，工厂就会给你生产出这个系列的玩具，而你不需要关心它们是怎么生产的。</p><p>这就是抽象工厂模式的核心思想，它让你能够轻松切换不同系列的产品，而不必关心每个产品是如何制造的。</p><p>以下是抽象工厂模式的关键要点和参与者：</p><ul><li><p><strong>抽象工厂（Abstract Factory）</strong>：定义了一组创建相关对象的方法，这些方法通常以接口或抽象类的形式提供。具体的工厂类将实现这个接口，每个工厂类负责创建一组相关的产品。</p></li><li><p><strong>具体工厂（Concrete Factory）</strong>：这些工厂类实现了抽象工厂接口，负责实际创建产品对象。每个具体工厂类都会创建一组相关的产品。</p></li><li><p><strong>抽象产品（Abstract Product）</strong>：定义了一组产品的接口，每个具体产品类都应该实现这个接口。</p></li><li><p><strong>具体产品（Concrete Product）</strong>：这些是实际的产品类，它们实现了抽象产品接口，由具体工厂类创建。</p></li></ul><p>抽象工厂模式的主要优点包括：</p><ol><li><p><strong>高内聚低耦合：</strong> 通过将相关对象的创建集中在一个工厂中，抽象工厂模式提供了高内聚性和低耦合性，有助于维护和扩展系统。</p></li><li><p><strong>易于替换：</strong> 客户端代码可以轻松替换一种具体工厂来切换整个产品家族，而无需修改现有代码。</p></li><li><p><strong>遵循开闭原则：</strong> 抽象工厂模式支持新产品的添加，而不需要修改现有代码。</p></li></ol><p>然而，抽象工厂模式也有一些限制：</p><ol><li><p><strong>复杂性增加：</strong> 随着产品家族的增长，抽象工厂模式可能会变得复杂，需要创建多个工厂类和产品类。</p></li><li><p><strong>不适用于单个产品的变化：</strong> 如果只有一个产品家族的一个部分需要变化，抽象工厂模式可能过于笨重。</p></li></ol><p>抽象工厂模式在需要创建一组相关对象并希望实现高内聚和低耦合的情况下非常有用。它在构建复杂的系统，如图形用户界面库或数据库驱动程序等方面得到广泛应用。</p><h3 id=示例代码>示例代码<a hidden class=anchor aria-hidden=true href=#示例代码>#</a></h3><p>以下是一个简单的Java示例代码，演示了抽象工厂模式的应用。在这个示例中，我们将创建一个界面工厂，其中包括按钮和文本框的抽象产品以及两个具体的工厂实现：Windows工厂和Mac工厂。每个具体工厂都负责创建相应操作系统风格下的按钮和文本框。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// 抽象产品：按钮
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>interface</span> <span class=nc>Button</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>paint</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 具体产品：Windows按钮
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>class</span> <span class=nc>WindowsButton</span> <span class=kd>implements</span> <span class=n>Button</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>paint</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Render a Windows button&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 具体产品：Mac按钮
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>class</span> <span class=nc>MacButton</span> <span class=kd>implements</span> <span class=n>Button</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>paint</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Render a Mac button&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 抽象产品：文本框
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>interface</span> <span class=nc>TextBox</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>display</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 具体产品：Windows文本框
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>class</span> <span class=nc>WindowsTextBox</span> <span class=kd>implements</span> <span class=n>TextBox</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>display</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Display a Windows text box&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 具体产品：Mac文本框
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>class</span> <span class=nc>MacTextBox</span> <span class=kd>implements</span> <span class=n>TextBox</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>display</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Display a Mac text box&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 抽象工厂接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>interface</span> <span class=nc>GUIFactory</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Button</span> <span class=nf>createButton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>TextBox</span> <span class=nf>createTextBox</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 具体工厂：Windows工厂
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>class</span> <span class=nc>WindowsFactory</span> <span class=kd>implements</span> <span class=n>GUIFactory</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Button</span> <span class=nf>createButton</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>WindowsButton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>TextBox</span> <span class=nf>createTextBox</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>WindowsTextBox</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 具体工厂：Mac工厂
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>class</span> <span class=nc>MacFactory</span> <span class=kd>implements</span> <span class=n>GUIFactory</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Button</span> <span class=nf>createButton</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>MacButton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>TextBox</span> <span class=nf>createTextBox</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>MacTextBox</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>AbstractFactoryExample</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 创建一个Windows风格的工厂
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>GUIFactory</span> <span class=n>windowsFactory</span> <span class=o>=</span> <span class=k>new</span> <span class=n>WindowsFactory</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>Button</span> <span class=n>windowsButton</span> <span class=o>=</span> <span class=n>windowsFactory</span><span class=o>.</span><span class=na>createButton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>TextBox</span> <span class=n>windowsTextBox</span> <span class=o>=</span> <span class=n>windowsFactory</span><span class=o>.</span><span class=na>createTextBox</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>windowsButton</span><span class=o>.</span><span class=na>paint</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>windowsTextBox</span><span class=o>.</span><span class=na>display</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 创建一个Mac风格的工厂
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>GUIFactory</span> <span class=n>macFactory</span> <span class=o>=</span> <span class=k>new</span> <span class=n>MacFactory</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>Button</span> <span class=n>macButton</span> <span class=o>=</span> <span class=n>macFactory</span><span class=o>.</span><span class=na>createButton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>TextBox</span> <span class=n>macTextBox</span> <span class=o>=</span> <span class=n>macFactory</span><span class=o>.</span><span class=na>createTextBox</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>macButton</span><span class=o>.</span><span class=na>paint</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>macTextBox</span><span class=o>.</span><span class=na>display</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>常见面试题</p><h3 id=什么是抽象工厂模式><strong>什么是抽象工厂模式？</strong><a hidden class=anchor aria-hidden=true href=#什么是抽象工厂模式>#</a></h3><ul><li>抽象工厂模式就是使用一个接口，使用这个接口创建一系列相关的对象，而无需指定它们的具体类。这允许客户端代码与具体对象的创建过程解耦，以支持创建不同产品家族。</li></ul><h3 id=抽象工厂模式与工厂方法模式有什么不同><strong>抽象工厂模式与工厂方法模式有什么不同？</strong><a hidden class=anchor aria-hidden=true href=#抽象工厂模式与工厂方法模式有什么不同>#</a></h3><ul><li>抽象工厂模式与工厂方法模式的主要区别在于范围。抽象工厂模式创建一整套产品家族，而工厂方法模式只创建一个产品。抽象工厂模式的具体工厂类通常创建多个相关产品，而工厂方法模式的具体工厂类只创建一个产品。</li></ul><h3 id=抽象工厂模式的应用场景是什么><strong>抽象工厂模式的应用场景是什么？</strong><a hidden class=anchor aria-hidden=true href=#抽象工厂模式的应用场景是什么>#</a></h3><ul><li>抽象工厂模式适用于需要创建一组相关对象的情况，如创建跨平台用户界面组件（按钮、文本框等），不同数据库连接的驱动程序，或者不同主题的应用程序皮肤等。</li></ul><h3 id=抽象工厂模式的优点和缺点是什么><strong>抽象工厂模式的优点和缺点是什么？</strong><a hidden class=anchor aria-hidden=true href=#抽象工厂模式的优点和缺点是什么>#</a></h3><ul><li>优点包括高内聚、低耦合，支持创建不同产品家族，符合开闭原则。缺点包括增加复杂性，不适用于单个产品变化的情况。</li></ul><h3 id=可以举例说明抽象工厂模式在编程中的具体实现吗><strong>可以举例说明抽象工厂模式在编程中的具体实现吗？</strong><a hidden class=anchor aria-hidden=true href=#可以举例说明抽象工厂模式在编程中的具体实现吗>#</a></h3><ul><li>示例代码见前面的Java示例，其中使用抽象工厂模式创建了不同操作系统下的UI组件。</li></ul><h3 id=抽象工厂模式和单例模式之间是否有联系><strong>抽象工厂模式和单例模式之间是否有联系？</strong><a hidden class=anchor aria-hidden=true href=#抽象工厂模式和单例模式之间是否有联系>#</a></h3><ul><li>抽象工厂模式和单例模式没有直接联系，但具体工厂类可以是单例，以确保只有一个工厂实例用于创建产品。</li></ul><h3 id=抽象工厂模式与其他设计模式的结合使用情况如何><strong>抽象工厂模式与其他设计模式的结合使用情况如何？</strong><a hidden class=anchor aria-hidden=true href=#抽象工厂模式与其他设计模式的结合使用情况如何>#</a></h3><ul><li>抽象工厂模式通常与其他模式如观察者模式、策略模式等结合使用。例如，可以使用策略模式定义不同算法，而抽象工厂模式用于创建特定算法的实例。</li></ul><h3 id=什么是抽象产品和具体产品><strong>什么是抽象产品和具体产品？</strong><a hidden class=anchor aria-hidden=true href=#什么是抽象产品和具体产品>#</a></h3><ul><li>抽象产品是产品的接口或抽象类，它定义了产品的通用行为。具体产品是实际的产品类，它们实现了抽象产品的接口或继承了抽象产品的抽象类，以提供具体的行为。</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://cheneydev.github.io/posts/2023-10-14-java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><span class=title>Next »</span><br><span>Java 学习笔记</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 设计模式学习笔记 on twitter" href="https://twitter.com/intent/tweet/?text=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 设计模式学习笔记 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;title=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&amp;summary=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&amp;source=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 设计模式学习笔记 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f&title=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 设计模式学习笔记 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 设计模式学习笔记 on whatsapp" href="https://api.whatsapp.com/send?text=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%20-%20https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 设计模式学习笔记 on telegram" href="https://telegram.me/share/url?text=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-21-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://cheneydev.github.io/>Cheney's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>