<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java 学习笔记 | Cheney's blog</title><meta name=keywords content><meta name=description content="基础知识 基本数据类型、包装类、字节数 基本数据类型 包装类型 字节数 byte Byte 1 short Short 2 int Integer 4 long Long 8 float Float 4 double Double 8 boolean Boolean 1（通常） 面向对象三大特征 特征 描述 封装 (Encapsulation) 数据和操作方法封装在单元内，限制外部访问，确保数据安全性。 继承 (Inheritance) 子类可以基于父类的属性和方法扩展其它属性和方法，促进代码重用和扩展性。 多态 (Polymorphism) 不同对象对同一消息有不同响应，提高灵活性和可维护性。 abstract 和 interface 抽象类（abstract class）是一种类，可以包含抽象方法和具体方法，支持单一继承，而接口（interface）是一种纯抽象类型，只包含抽象方法，支持多重继承。
特点 抽象类 接口 类型 类 接口（纯抽象类型） 方法 可包含抽象方法和具体方法 只包含抽象方法，没有具体方法 字段 可包含字段 不包含字段 继承和实现 可以继承一个抽象类 类可以实现多个接口 多重继承 不支持多重继承 类可以同时实现多个接口 实例化 不能实例化 不能实例化 访问修饰符 可以使用各种访问修饰符（public、protected、private等） 方法默认为public和abstract 方法覆盖（重写） 子类必须覆盖抽象方法，除非子类也是抽象类 实现类必须提供接口中定义的所有方法的具体实现 用途 构建类层次结构，提供通用实现和规范 定义契约，实现多态，允许类共享通用方法 集合 List,Set,Map 三者的区别？底层数据结构？ 集合类型 具体实现类 底层数据结构 有序性 重复元素 List ArrayList 数组 有序 可重复 LinkedList 双向链表 有序 可重复 Set HashSet 哈希表（基于 HashMap） 无序 不可重复 LinkedHashSet 哈希表和双向链表（基于 LinkedHashMap） 有序 不可重复 TreeSet 红黑树 有序 不可重复 Map HashMap 哈希表 无序 不可重复 LinkedHashMap 哈希表和双向链表 有序 不可重复 TreeMap 红黑树 有序 不可重复 有哪些集合是线程不安全的？怎么解决？ 在 Java 中，许多标准集合类是线程不安全的，这意味着它们在多线程环境下可能会导致不确定的行为或数据损坏。一些常见的线程不安全的集合包括："><meta name=author content="Me"><link rel=canonical href=https://cheneydev.github.io/posts/2023-10-14-java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Java 学习笔记"><meta property="og:description" content="基础知识 基本数据类型、包装类、字节数 基本数据类型 包装类型 字节数 byte Byte 1 short Short 2 int Integer 4 long Long 8 float Float 4 double Double 8 boolean Boolean 1（通常） 面向对象三大特征 特征 描述 封装 (Encapsulation) 数据和操作方法封装在单元内，限制外部访问，确保数据安全性。 继承 (Inheritance) 子类可以基于父类的属性和方法扩展其它属性和方法，促进代码重用和扩展性。 多态 (Polymorphism) 不同对象对同一消息有不同响应，提高灵活性和可维护性。 abstract 和 interface 抽象类（abstract class）是一种类，可以包含抽象方法和具体方法，支持单一继承，而接口（interface）是一种纯抽象类型，只包含抽象方法，支持多重继承。
特点 抽象类 接口 类型 类 接口（纯抽象类型） 方法 可包含抽象方法和具体方法 只包含抽象方法，没有具体方法 字段 可包含字段 不包含字段 继承和实现 可以继承一个抽象类 类可以实现多个接口 多重继承 不支持多重继承 类可以同时实现多个接口 实例化 不能实例化 不能实例化 访问修饰符 可以使用各种访问修饰符（public、protected、private等） 方法默认为public和abstract 方法覆盖（重写） 子类必须覆盖抽象方法，除非子类也是抽象类 实现类必须提供接口中定义的所有方法的具体实现 用途 构建类层次结构，提供通用实现和规范 定义契约，实现多态，允许类共享通用方法 集合 List,Set,Map 三者的区别？底层数据结构？ 集合类型 具体实现类 底层数据结构 有序性 重复元素 List ArrayList 数组 有序 可重复 LinkedList 双向链表 有序 可重复 Set HashSet 哈希表（基于 HashMap） 无序 不可重复 LinkedHashSet 哈希表和双向链表（基于 LinkedHashMap） 有序 不可重复 TreeSet 红黑树 有序 不可重复 Map HashMap 哈希表 无序 不可重复 LinkedHashMap 哈希表和双向链表 有序 不可重复 TreeMap 红黑树 有序 不可重复 有哪些集合是线程不安全的？怎么解决？ 在 Java 中，许多标准集合类是线程不安全的，这意味着它们在多线程环境下可能会导致不确定的行为或数据损坏。一些常见的线程不安全的集合包括："><meta property="og:type" content="article"><meta property="og:url" content="https://cheneydev.github.io/posts/2023-10-14-java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:image" content="https://cheneydev.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-14T10:38:40+08:00"><meta property="article:modified_time" content="2023-10-14T10:38:40+08:00"><meta property="og:site_name" content="Cheney Wang"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cheneydev.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Java 学习笔记"><meta name=twitter:description content="基础知识 基本数据类型、包装类、字节数 基本数据类型 包装类型 字节数 byte Byte 1 short Short 2 int Integer 4 long Long 8 float Float 4 double Double 8 boolean Boolean 1（通常） 面向对象三大特征 特征 描述 封装 (Encapsulation) 数据和操作方法封装在单元内，限制外部访问，确保数据安全性。 继承 (Inheritance) 子类可以基于父类的属性和方法扩展其它属性和方法，促进代码重用和扩展性。 多态 (Polymorphism) 不同对象对同一消息有不同响应，提高灵活性和可维护性。 abstract 和 interface 抽象类（abstract class）是一种类，可以包含抽象方法和具体方法，支持单一继承，而接口（interface）是一种纯抽象类型，只包含抽象方法，支持多重继承。
特点 抽象类 接口 类型 类 接口（纯抽象类型） 方法 可包含抽象方法和具体方法 只包含抽象方法，没有具体方法 字段 可包含字段 不包含字段 继承和实现 可以继承一个抽象类 类可以实现多个接口 多重继承 不支持多重继承 类可以同时实现多个接口 实例化 不能实例化 不能实例化 访问修饰符 可以使用各种访问修饰符（public、protected、private等） 方法默认为public和abstract 方法覆盖（重写） 子类必须覆盖抽象方法，除非子类也是抽象类 实现类必须提供接口中定义的所有方法的具体实现 用途 构建类层次结构，提供通用实现和规范 定义契约，实现多态，允许类共享通用方法 集合 List,Set,Map 三者的区别？底层数据结构？ 集合类型 具体实现类 底层数据结构 有序性 重复元素 List ArrayList 数组 有序 可重复 LinkedList 双向链表 有序 可重复 Set HashSet 哈希表（基于 HashMap） 无序 不可重复 LinkedHashSet 哈希表和双向链表（基于 LinkedHashMap） 有序 不可重复 TreeSet 红黑树 有序 不可重复 Map HashMap 哈希表 无序 不可重复 LinkedHashMap 哈希表和双向链表 有序 不可重复 TreeMap 红黑树 有序 不可重复 有哪些集合是线程不安全的？怎么解决？ 在 Java 中，许多标准集合类是线程不安全的，这意味着它们在多线程环境下可能会导致不确定的行为或数据损坏。一些常见的线程不安全的集合包括："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cheneydev.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Java 学习笔记","item":"https://cheneydev.github.io/posts/2023-10-14-java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java 学习笔记","name":"Java 学习笔记","description":"基础知识 基本数据类型、包装类、字节数 基本数据类型 包装类型 字节数 byte Byte 1 short Short 2 int Integer 4 long Long 8 float Float 4 double Double 8 boolean Boolean 1（通常） 面向对象三大特征 特征 描述 封装 (Encapsulation) 数据和操作方法封装在单元内，限制外部访问，确保数据安全性。 继承 (Inheritance) 子类可以基于父类的属性和方法扩展其它属性和方法，促进代码重用和扩展性。 多态 (Polymorphism) 不同对象对同一消息有不同响应，提高灵活性和可维护性。 abstract 和 interface 抽象类（abstract class）是一种类，可以包含抽象方法和具体方法，支持单一继承，而接口（interface）是一种纯抽象类型，只包含抽象方法，支持多重继承。\n特点 抽象类 接口 类型 类 接口（纯抽象类型） 方法 可包含抽象方法和具体方法 只包含抽象方法，没有具体方法 字段 可包含字段 不包含字段 继承和实现 可以继承一个抽象类 类可以实现多个接口 多重继承 不支持多重继承 类可以同时实现多个接口 实例化 不能实例化 不能实例化 访问修饰符 可以使用各种访问修饰符（public、protected、private等） 方法默认为public和abstract 方法覆盖（重写） 子类必须覆盖抽象方法，除非子类也是抽象类 实现类必须提供接口中定义的所有方法的具体实现 用途 构建类层次结构，提供通用实现和规范 定义契约，实现多态，允许类共享通用方法 集合 List,Set,Map 三者的区别？底层数据结构？ 集合类型 具体实现类 底层数据结构 有序性 重复元素 List ArrayList 数组 有序 可重复 LinkedList 双向链表 有序 可重复 Set HashSet 哈希表（基于 HashMap） 无序 不可重复 LinkedHashSet 哈希表和双向链表（基于 LinkedHashMap） 有序 不可重复 TreeSet 红黑树 有序 不可重复 Map HashMap 哈希表 无序 不可重复 LinkedHashMap 哈希表和双向链表 有序 不可重复 TreeMap 红黑树 有序 不可重复 有哪些集合是线程不安全的？怎么解决？ 在 Java 中，许多标准集合类是线程不安全的，这意味着它们在多线程环境下可能会导致不确定的行为或数据损坏。一些常见的线程不安全的集合包括：","keywords":[],"articleBody":"基础知识 基本数据类型、包装类、字节数 基本数据类型 包装类型 字节数 byte Byte 1 short Short 2 int Integer 4 long Long 8 float Float 4 double Double 8 boolean Boolean 1（通常） 面向对象三大特征 特征 描述 封装 (Encapsulation) 数据和操作方法封装在单元内，限制外部访问，确保数据安全性。 继承 (Inheritance) 子类可以基于父类的属性和方法扩展其它属性和方法，促进代码重用和扩展性。 多态 (Polymorphism) 不同对象对同一消息有不同响应，提高灵活性和可维护性。 abstract 和 interface 抽象类（abstract class）是一种类，可以包含抽象方法和具体方法，支持单一继承，而接口（interface）是一种纯抽象类型，只包含抽象方法，支持多重继承。\n特点 抽象类 接口 类型 类 接口（纯抽象类型） 方法 可包含抽象方法和具体方法 只包含抽象方法，没有具体方法 字段 可包含字段 不包含字段 继承和实现 可以继承一个抽象类 类可以实现多个接口 多重继承 不支持多重继承 类可以同时实现多个接口 实例化 不能实例化 不能实例化 访问修饰符 可以使用各种访问修饰符（public、protected、private等） 方法默认为public和abstract 方法覆盖（重写） 子类必须覆盖抽象方法，除非子类也是抽象类 实现类必须提供接口中定义的所有方法的具体实现 用途 构建类层次结构，提供通用实现和规范 定义契约，实现多态，允许类共享通用方法 集合 List,Set,Map 三者的区别？底层数据结构？ 集合类型 具体实现类 底层数据结构 有序性 重复元素 List ArrayList 数组 有序 可重复 LinkedList 双向链表 有序 可重复 Set HashSet 哈希表（基于 HashMap） 无序 不可重复 LinkedHashSet 哈希表和双向链表（基于 LinkedHashMap） 有序 不可重复 TreeSet 红黑树 有序 不可重复 Map HashMap 哈希表 无序 不可重复 LinkedHashMap 哈希表和双向链表 有序 不可重复 TreeMap 红黑树 有序 不可重复 有哪些集合是线程不安全的？怎么解决？ 在 Java 中，许多标准集合类是线程不安全的，这意味着它们在多线程环境下可能会导致不确定的行为或数据损坏。一些常见的线程不安全的集合包括：\nArrayList：ArrayList 不是线程安全的，多个线程同时修改它可能导致数据不一致。\nHashMap：HashMap 也是线程不安全的，多线程同时进行插入、删除、或更新操作可能导致问题。\nHashSet：HashSet 同样是线程不安全的。\nLinkedList：LinkedList 在多线程环境下也不安全。\n解决线程不安全问题的常见方法包括：\n使用同步（Synchronization）：你可以使用关键字 synchronized 来保护对集合的操作。这会确保在同一时间只有一个线程能够访问集合，从而避免竞态条件。例如：\nList\u003cString\u003e synchronizedList = Collections.synchronizedList(new ArrayList\u003c\u003e()); 或\nsynchronized (myList) { // 执行需要同步的操作 } 这种方法虽然有效，但可能会引起性能问题，因为它会阻塞其他线程的访问。\n使用线程安全的集合：Java 提供了线程安全的集合类，如 CopyOnWriteArrayList、ConcurrentHashMap 等。这些集合类使用了更复杂的内部算法，以提供更高的并发性能。\n例如，ConcurrentHashMap 可以被用来替代普通的 HashMap，它在多线程环境下能够提供更好的性能。\nMap\u003cString, String\u003e concurrentMap = new ConcurrentHashMap\u003c\u003e(); 使用并发集合工具：Java 5+ 引入了一些并发集合工具，如 java.util.concurrent 包下的 ConcurrentLinkedQueue、BlockingQueue 等。这些工具提供了更高级别的线程安全操作，可以更容易地处理并发问题。\n总之，选择解决线程不安全问题的方法取决于具体的情况。在多线程环境下，确保使用适当的数据结构和同步机制，以防止数据损坏或不确定的行为。\nHashMap 底层实现 HashMap 在 JDK 1.7 和 JDK 1.8 的底层实现是不一样的，在 JDK 1.7 中，HashMap 使用的是数组 + 链表实现的，而 JDK 1.8 中使用的是数组 + 链表或红黑树实现的。\nHashMap 中每个元素称之为一个哈希桶（bucket），哈希桶包含的内容有 4 个：\nhash 值 key value next（下一个节点） Hash 冲突解决 HashMap 解决哈希冲突的方式主要是通过链表和红黑树（在Java 8及以后的版本中）来实现。哈希冲突发生在不同键具有相同哈希码的情况下。以下是 HashMap 如何解决哈希冲突的过程：\n链表（Java 7之前）：\n当发生哈希冲突时，HashMap 将新的键值对添加到存储位置（桶）的链表中。 如果多个键的哈希码相同，它们将按顺序连接在同一个链表上。 在查找键值对时，HashMap会遍历该链表，依次比较键的值，以找到匹配的键值对。 红黑树（Java 8及以后）：\n在Java 8及以后的版本中，如果一个桶中的链表过长（达到一定阈值），它将被转换为红黑树以提高性能。 红黑树是一种自平衡二叉搜索树，它具有更好的查找性能，通常在大型哈希冲突链表中表现更好。 红黑树的插入、查找和删除操作通常具有较好的时间复杂度。 通过使用链表和红黑树，HashMap确保即使在有哈希冲突的情况下，仍然能够以较高的性能执行插入、查找和删除操作。这种解决冲突的方式使HashMap能够应对各种不同类型的哈希码分布，确保了其数据结构的高效性和可靠性。\nHashMap 插入流程 HashMap 元素新增的实现源码如下：\npublic V put(K key, V value) { // 对 key 进行哈希操作 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node[] tab; Node p; int n, i; // 哈希表为空则创建表 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 根据 key 的哈希值计算出要插入的数组索引 i if ((p = tab[i = (n - 1) \u0026 hash]) == null) // 如果 table[i] 等于 null，则直接插入 tab[i] = newNode(hash, key, value, null); else { Node e; K k; // 如果 key 已经存在了，直接覆盖 value if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; // 如果 key 不存在，判断是否为红黑树 else if (p instanceof TreeNode) // 红黑树直接插入键值对 e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); else { // 为链表结构，循环准备插入 for (int binCount = 0; ; ++binCount) { // 下一个元素为空时 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 转换为红黑树进行处理 if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // key 已经存在直接覆盖 value if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 超过最大容量，扩容 if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } 来源：面试突击15：说一下HashMap底层实现？及元素添加流程？\n参考资料：Internal Working of HashMap in Java\n介绍 Hashtable Hashtable 是 Java 中的一个早期的哈希表实现，它用于存储键值对，并提供快速的查找、插入和删除操作。Hashtable 在 Java 的早期版本中是唯一的线程安全的哈希表实现，但现在更常见的是使用 HashMap 或 ConcurrentHashMap，因为它们提供更好的性能和灵活性。\n以下是关于 Hashtable 的一些重要信息：\n线程安全性： Hashtable 是线程安全的，这意味着多个线程可以同时访问和修改 Hashtable，而不会导致数据不一致。这是通过在每个公共方法上使用 synchronized 关键字来实现的。虽然线程安全，但这也可能导致性能下降，因为每个方法调用都需要获取锁。 键值对： Hashtable 存储键值对，其中键和值都是对象。键用于查找值，因此键必须是唯一的，且不能为 null。 底层数据结构： Hashtable 使用哈希表作为底层数据结构，它使用键的哈希码来快速查找值。哈希表将键映射到特定的索引位置，使查找操作非常高效。 遍历： 可以使用迭代器或 Enumeration 来遍历 Hashtable 中的键值对。 示例使用 Hashtable：\nimport java.util.Hashtable; public class HashtableExample { public static void main(String[] args) { Hashtable\u003cString, Integer\u003e table = new Hashtable\u003c\u003e(); table.put(\"one\", 1); table.put(\"two\", 2); table.put(\"three\", 3); int value = table.get(\"two\"); System.out.println(\"Value for key 'two': \" + value); } } 尽管 Hashtable 仍然可以使用，但在现代 Java 应用程序中，通常更倾向于使用 HashMap 或其他更现代的集合类来实现类似的功能，以获得更好的性能和可维护性。\nHashMap 和 Hashtable 区别？ 线程安全性： 最大的区别是线程安全性。HashMap 不是线程安全的，而 Hashtable 是线程安全的。这意味着在多线程环境下，多个线程可以同时访问和修改 HashMap，但必须同步访问 Hashtable。\nnull 键和值： HashMap 允许有一个 null 键和多个 null 值，而 Hashtable 不允许有 null 键或值。\n继承关系： Hashtable 是一个旧的遗留类，而 HashMap 是它的替代品。HashMap 是基于哈希表的实现，性能通常更好。\n迭代： 在 HashMap 中使用迭代器（如 Iterator）进行迭代，而在 Hashtable 中使用 Enumeration 进行迭代。\nHashMap 和 HashSet 区别？ 数据类型： HashMap 是键值对的集合，用于映射键到值。HashSet 是存储唯一元素的集合，不包含键值对。\n底层数据结构： HashMap 使用哈希表作为底层数据结构，用于快速查找键值对。HashSet 基于 HashMap 实现，它只使用键而没有值。\n重复元素： HashMap 允许重复的键，但不允许重复的值。HashSet 只允许存储不重复的元素。\n用途： HashMap 用于映射键到值的情况，而 HashSet 用于维护唯一元素的情况。\nHashMap 和 TreeMap 区别？ 有序性： HashMap 是无序的，元素的顺序不受控制。TreeMap 是有序的，元素按照键的自然顺序或提供的比较器进行排序。 底层数据结构： HashMap 使用哈希表，TreeMap 使用红黑树作为底层数据结构。因此，TreeMap 提供了有序性，但在插入和删除操作上性能通常较慢。 遍历性能： HashMap 的遍历性能通常比 TreeMap 快，但没有特定的顺序。TreeMap 可以按顺序遍历元素。 键的比较： HashMap 使用哈希码来快速查找键，而 TreeMap 使用比较操作（根据键的自然顺序或提供的比较器）来排序键。 ConcurrentHashMap 和 Hashtable 的区别？ 特征 ConcurrentHashMap Hashtable 线程安全性 使用分段锁，允许多个线程并发访问不同分段 使用全局锁，一次只允许一个线程执行读或写操作 Null 值 允许 null 键和 null 值 不允许 null 键或 null 值 遍历性能 通常具有更好的遍历性能 遍历性能相对较差 类型 相对较新的现代并发集合类 旧的、遗留的集合类 为什么 HashTable 不允许 null 为键或者值？ Hashtable 是支持并发操作的，但这引发了一个潜在的问题。当你使用 get(k) 方法来获取对应的 value 时，如果返回的值是 null，你无法确定这个 null 值是由于在 put(k, v) 时 value 被设为 null，还是因为这个 key 从未被映射过。相比之下，HashMap 是非并发的，你可以通过 contains(key) 方法来明确判断键是否存在。\n在支持并发的 Map 上调用 m.contains(key) 和 m.get(key) 之间可能会存在并发变化，这使得准确判断 null 值的来源变得复杂。\n多线程 进程（Process）和线程（Thread） 特点 进程 线程 定义 独立的程序实例 进程内的执行单元 资源消耗 需要独立内存和系统资源，开销大 共享内存和资源，开销小 通信和同步 通信需要使用IPC机制，同步较复杂 直接共享内存，同步相对容易 安全性 进程崩溃不影响其他进程，较安全 一个线程的错误可能影响整个进程的稳定性 创建和销毁 创建和销毁进程较慢复杂 创建和销毁线程较快简单 并行性 进程可以在多处理器上并行执行 线程在多核处理器上并行执行更容易 ","wordCount":"721","inLanguage":"en","datePublished":"2023-10-14T10:38:40+08:00","dateModified":"2023-10-14T10:38:40+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheneydev.github.io/posts/2023-10-14-java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"Cheney's blog","logo":{"@type":"ImageObject","url":"https://cheneydev.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cheneydev.github.io/ accesskey=h title="Cheney's blog (Alt + H)"><img src=https://cheneydev.github.io/apple-touch-icon.png alt aria-label=logo height=35>Cheney's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cheneydev.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cheneydev.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cheneydev.github.io/posts/>Posts</a></div><h1 class=post-title>Java 学习笔记</h1><div class=post-meta><span title='2023-10-14 10:38:40 +0800 CST'>October 14, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;721 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/2023-10-14-Java-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=基础知识>基础知识<a hidden class=anchor aria-hidden=true href=#基础知识>#</a></h2><h3 id=基本数据类型包装类字节数>基本数据类型、包装类、字节数<a hidden class=anchor aria-hidden=true href=#基本数据类型包装类字节数>#</a></h3><table><thead><tr><th>基本数据类型</th><th>包装类型</th><th>字节数</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td><td>1</td></tr><tr><td>short</td><td>Short</td><td>2</td></tr><tr><td><strong>int</strong></td><td><strong>Integer</strong></td><td><strong>4</strong></td></tr><tr><td>long</td><td>Long</td><td>8</td></tr><tr><td>float</td><td>Float</td><td>4</td></tr><tr><td>double</td><td>Double</td><td>8</td></tr><tr><td>boolean</td><td>Boolean</td><td>1（通常）</td></tr></tbody></table><h3 id=面向对象三大特征>面向对象三大特征<a hidden class=anchor aria-hidden=true href=#面向对象三大特征>#</a></h3><table><thead><tr><th>特征</th><th>描述</th></tr></thead><tbody><tr><td>封装 (Encapsulation)</td><td>数据和操作方法封装在单元内，限制外部访问，确保数据安全性。</td></tr><tr><td>继承 (Inheritance)</td><td>子类可以基于父类的属性和方法扩展其它属性和方法，促进代码重用和扩展性。</td></tr><tr><td>多态 (Polymorphism)</td><td><strong>不同</strong>对象对<strong>同一</strong>消息有<strong>不同</strong>响应，提高灵活性和可维护性。</td></tr></tbody></table><h3 id=abstract-和-interface><code>abstract</code> 和 <code>interface</code><a hidden class=anchor aria-hidden=true href=#abstract-和-interface>#</a></h3><p>抽象类（abstract class）是一种类，可以包含抽象方法和具体方法，支持单一继承，而接口（interface）是一种纯抽象类型，只包含抽象方法，支持多重继承。</p><table><thead><tr><th>特点</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>类型</td><td>类</td><td>接口（纯抽象类型）</td></tr><tr><td>方法</td><td>可包含抽象方法和具体方法</td><td>只包含抽象方法，没有具体方法</td></tr><tr><td>字段</td><td>可包含字段</td><td>不包含字段</td></tr><tr><td>继承和实现</td><td>可以继承一个抽象类</td><td>类可以实现多个接口</td></tr><tr><td>多重继承</td><td>不支持多重继承</td><td>类可以同时实现多个接口</td></tr><tr><td>实例化</td><td>不能实例化</td><td>不能实例化</td></tr><tr><td>访问修饰符</td><td>可以使用各种访问修饰符（public、protected、private等）</td><td>方法默认为public和abstract</td></tr><tr><td>方法覆盖（重写）</td><td>子类必须覆盖抽象方法，除非子类也是抽象类</td><td>实现类必须提供接口中定义的所有方法的具体实现</td></tr><tr><td>用途</td><td>构建类层次结构，提供通用实现和规范</td><td>定义契约，实现多态，允许类共享通用方法</td></tr></tbody></table><h2 id=集合>集合<a hidden class=anchor aria-hidden=true href=#集合>#</a></h2><h3 id=listsetmap-三者的区别底层数据结构>List,Set,Map 三者的区别？底层数据结构？<a hidden class=anchor aria-hidden=true href=#listsetmap-三者的区别底层数据结构>#</a></h3><table><thead><tr><th>集合类型</th><th>具体实现类</th><th>底层数据结构</th><th>有序性</th><th>重复元素</th></tr></thead><tbody><tr><td>List</td><td>ArrayList</td><td>数组</td><td>有序</td><td>可重复</td></tr><tr><td></td><td>LinkedList</td><td>双向链表</td><td>有序</td><td>可重复</td></tr><tr><td>Set</td><td>HashSet</td><td>哈希表（基于 HashMap）</td><td>无序</td><td>不可重复</td></tr><tr><td></td><td>LinkedHashSet</td><td>哈希表和双向链表（基于 LinkedHashMap）</td><td>有序</td><td>不可重复</td></tr><tr><td></td><td>TreeSet</td><td>红黑树</td><td>有序</td><td>不可重复</td></tr><tr><td>Map</td><td>HashMap</td><td>哈希表</td><td>无序</td><td>不可重复</td></tr><tr><td></td><td>LinkedHashMap</td><td>哈希表和双向链表</td><td>有序</td><td>不可重复</td></tr><tr><td></td><td>TreeMap</td><td>红黑树</td><td>有序</td><td>不可重复</td></tr></tbody></table><h3 id=有哪些集合是线程不安全的怎么解决>有哪些集合是线程不安全的？怎么解决？<a hidden class=anchor aria-hidden=true href=#有哪些集合是线程不安全的怎么解决>#</a></h3><p>在 Java 中，许多标准集合类是线程不安全的，这意味着它们在多线程环境下可能会导致不确定的行为或数据损坏。一些常见的线程不安全的集合包括：</p><ol><li><p><code>ArrayList</code>：<code>ArrayList</code> 不是线程安全的，多个线程同时修改它可能导致数据不一致。</p></li><li><p><code>HashMap</code>：<code>HashMap</code> 也是线程不安全的，多线程同时进行插入、删除、或更新操作可能导致问题。</p></li><li><p><code>HashSet</code>：<code>HashSet</code> 同样是线程不安全的。</p></li><li><p><code>LinkedList</code>：<code>LinkedList</code> 在多线程环境下也不安全。</p></li></ol><p>解决线程不安全问题的常见方法包括：</p><ol><li><p>使用同步（Synchronization）：你可以使用关键字 <code>synchronized</code> 来保护对集合的操作。这会确保在同一时间只有一个线程能够访问集合，从而避免竞态条件。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>synchronizedList</span> <span class=o>=</span> <span class=n>Collections</span><span class=o>.</span><span class=na>synchronizedList</span><span class=o>(</span><span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;());</span>
</span></span></code></pre></div><p>或</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>synchronized</span> <span class=o>(</span><span class=n>myList</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 执行需要同步的操作
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></div><p>这种方法虽然有效，但可能会引起性能问题，因为它会阻塞其他线程的访问。</p></li><li><p>使用线程安全的集合：Java 提供了线程安全的集合类，如 <code>CopyOnWriteArrayList</code>、<code>ConcurrentHashMap</code> 等。这些集合类使用了更复杂的内部算法，以提供更高的并发性能。</p><p>例如，<code>ConcurrentHashMap</code> 可以被用来替代普通的 <code>HashMap</code>，它在多线程环境下能够提供更好的性能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=n>concurrentMap</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ConcurrentHashMap</span><span class=o>&lt;&gt;();</span>
</span></span></code></pre></div></li><li><p>使用并发集合工具：Java 5+ 引入了一些并发集合工具，如 <code>java.util.concurrent</code> 包下的 <code>ConcurrentLinkedQueue</code>、<code>BlockingQueue</code> 等。这些工具提供了更高级别的线程安全操作，可以更容易地处理并发问题。</p></li></ol><p>总之，选择解决线程不安全问题的方法取决于具体的情况。在多线程环境下，确保使用适当的数据结构和同步机制，以防止数据损坏或不确定的行为。</p><h3 id=hashmap-底层实现>HashMap 底层实现<a hidden class=anchor aria-hidden=true href=#hashmap-底层实现>#</a></h3><p>HashMap 在 JDK 1.7 和 JDK 1.8 的底层实现是不一样的，<strong>在 JDK 1.7 中，HashMap 使用的是数组 + 链表实现的，而 JDK 1.8 中使用的是数组 + 链表或红黑树实现的</strong>。</p><p>HashMap 中每个元素称之为一个哈希桶（bucket），哈希桶包含的内容有 4 个：</p><pre tabindex=0><code>hash 值
key
value
next（下一个节点）
</code></pre><h3 id=hash-冲突解决>Hash 冲突解决<a hidden class=anchor aria-hidden=true href=#hash-冲突解决>#</a></h3><p>HashMap 解决哈希冲突的方式主要是通过链表和红黑树（在Java 8及以后的版本中）来实现。哈希冲突发生在不同键具有相同哈希码的情况下。以下是 HashMap 如何解决哈希冲突的过程：</p><ol><li><p><strong>链表（Java 7之前）</strong>：</p><ul><li>当发生哈希冲突时，HashMap 将新的键值对添加到存储位置（桶）的链表中。</li><li>如果多个键的哈希码相同，它们将按顺序连接在同一个链表上。</li><li>在查找键值对时，HashMap会遍历该链表，依次比较键的值，以找到匹配的键值对。</li></ul></li><li><p><strong>红黑树（Java 8及以后）</strong>：</p><ul><li>在Java 8及以后的版本中，如果一个桶中的链表过长（达到一定阈值），它将被转换为红黑树以提高性能。</li><li>红黑树是一种自平衡二叉搜索树，它具有更好的查找性能，通常在大型哈希冲突链表中表现更好。</li><li>红黑树的插入、查找和删除操作通常具有较好的时间复杂度。</li></ul></li></ol><p>通过使用链表和红黑树，HashMap确保即使在有哈希冲突的情况下，仍然能够以较高的性能执行插入、查找和删除操作。这种解决冲突的方式使HashMap能够应对各种不同类型的哈希码分布，确保了其数据结构的高效性和可靠性。</p><h3 id=hashmap-插入流程>HashMap 插入流程<a hidden class=anchor aria-hidden=true href=#hashmap-插入流程>#</a></h3><p>HashMap 元素新增的实现源码如下：</p><pre tabindex=0><code>public V put(K key, V value) {
    // 对 key 进行哈希操作
    return putVal(hash(key), key, value, false, true);
}
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    // 哈希表为空则创建表
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // 根据 key 的哈希值计算出要插入的数组索引 i
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        // 如果 table[i] 等于 null，则直接插入
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&lt;K,V&gt; e; K k;
        // 如果 key 已经存在了，直接覆盖 value
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        // 如果 key 不存在，判断是否为红黑树
        else if (p instanceof TreeNode)
            // 红黑树直接插入键值对
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            // 为链表结构，循环准备插入
            for (int binCount = 0; ; ++binCount) {
                // 下一个元素为空时
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    // 转换为红黑树进行处理
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                //  key 已经存在直接覆盖 value
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    // 超过最大容量，扩容
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
</code></pre><p><img loading=lazy src=./HashMap%e6%8f%92%e5%85%a5%e6%b5%81%e7%a8%8b%e5%9b%be%e8%a7%a3.png alt></p><blockquote><p>来源：<a href=https://www.cnblogs.com/vipstone/p/15796245.html>面试突击15：说一下HashMap底层实现？及元素添加流程？</a></p><p>参考资料：<a href=https://medium.com/@basecs101/internal-working-of-hashmap-in-java-latest-updated-4c2708f76d2c>Internal Working of HashMap in Java</a></p></blockquote><h3 id=介绍-hashtable>介绍 Hashtable<a hidden class=anchor aria-hidden=true href=#介绍-hashtable>#</a></h3><p><code>Hashtable</code> 是 Java 中的一个早期的哈希表实现，它用于存储键值对，并提供快速的查找、插入和删除操作。<code>Hashtable</code> 在 Java 的早期版本中是唯一的线程安全的哈希表实现，但现在更常见的是使用 <code>HashMap</code> 或 <code>ConcurrentHashMap</code>，因为它们提供更好的性能和灵活性。</p><p>以下是关于 <code>Hashtable</code> 的一些重要信息：</p><ol><li><strong>线程安全性：</strong> <code>Hashtable</code> 是线程安全的，这意味着多个线程可以同时访问和修改 <code>Hashtable</code>，而不会导致数据不一致。这是通过在每个公共方法上使用 <code>synchronized</code> 关键字来实现的。虽然线程安全，但这也可能导致性能下降，因为每个方法调用都需要获取锁。</li><li><strong>键值对：</strong> <code>Hashtable</code> 存储键值对，其中键和值都是对象。键用于查找值，因此键必须是唯一的，且不能为 <code>null</code>。</li><li><strong>底层数据结构：</strong> <code>Hashtable</code> 使用哈希表作为底层数据结构，它使用键的哈希码来快速查找值。哈希表将键映射到特定的索引位置，使查找操作非常高效。</li><li><strong>遍历：</strong> 可以使用迭代器或 Enumeration 来遍历 <code>Hashtable</code> 中的键值对。</li></ol><p>示例使用 <code>Hashtable</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.util.Hashtable</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>HashtableExample</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Hashtable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>table</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Hashtable</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=n>table</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;one&#34;</span><span class=o>,</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>table</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;two&#34;</span><span class=o>,</span> <span class=mi>2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>table</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;three&#34;</span><span class=o>,</span> <span class=mi>3</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=n>table</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=s>&#34;two&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Value for key &#39;two&#39;: &#34;</span> <span class=o>+</span> <span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>尽管 <code>Hashtable</code> 仍然可以使用，但在现代 Java 应用程序中，通常更倾向于使用 <code>HashMap</code> 或其他更现代的集合类来实现类似的功能，以获得更好的性能和可维护性。</p><h3 id=hashmap-和-hashtable-区别>HashMap 和 Hashtable 区别？<a hidden class=anchor aria-hidden=true href=#hashmap-和-hashtable-区别>#</a></h3><ul><li><p><strong>线程安全性：</strong> 最大的区别是线程安全性。HashMap 不是线程安全的，而 Hashtable 是线程安全的。这意味着在多线程环境下，多个线程可以同时访问和修改 HashMap，但必须同步访问 Hashtable。</p></li><li><p><strong>null 键和值：</strong> HashMap 允许有一个 null 键和多个 null 值，而 Hashtable 不允许有 null 键或值。</p></li><li><p><strong>继承关系：</strong> Hashtable 是一个旧的遗留类，而 HashMap 是它的替代品。HashMap 是基于哈希表的实现，性能通常更好。</p></li><li><p><strong>迭代：</strong> 在 HashMap 中使用迭代器（如 Iterator）进行迭代，而在 Hashtable 中使用 Enumeration 进行迭代。</p></li></ul><h3 id=hashmap-和-hashset-区别>HashMap 和 HashSet 区别？<a hidden class=anchor aria-hidden=true href=#hashmap-和-hashset-区别>#</a></h3><ul><li><p><strong>数据类型：</strong> HashMap 是键值对的集合，用于映射键到值。HashSet 是存储唯一元素的集合，不包含键值对。</p></li><li><p><strong>底层数据结构：</strong> HashMap 使用哈希表作为底层数据结构，用于快速查找键值对。HashSet 基于 HashMap 实现，它只使用键而没有值。</p></li><li><p><strong>重复元素：</strong> HashMap 允许重复的键，但不允许重复的值。HashSet 只允许存储不重复的元素。</p></li><li><p><strong>用途：</strong> HashMap 用于映射键到值的情况，而 HashSet 用于维护唯一元素的情况。</p></li></ul><h3 id=hashmap-和-treemap-区别>HashMap 和 TreeMap 区别？<a hidden class=anchor aria-hidden=true href=#hashmap-和-treemap-区别>#</a></h3><ul><li><strong>有序性：</strong> HashMap 是无序的，元素的顺序不受控制。TreeMap 是有序的，元素按照键的自然顺序或提供的比较器进行排序。</li><li><strong>底层数据结构：</strong> HashMap 使用哈希表，TreeMap 使用红黑树作为底层数据结构。因此，TreeMap 提供了有序性，但在插入和删除操作上性能通常较慢。</li><li><strong>遍历性能：</strong> HashMap 的遍历性能通常比 TreeMap 快，但没有特定的顺序。TreeMap 可以按顺序遍历元素。</li><li><strong>键的比较：</strong> HashMap 使用哈希码来快速查找键，而 TreeMap 使用比较操作（根据键的自然顺序或提供的比较器）来排序键。</li></ul><h3 id=concurrenthashmap-和-hashtable-的区别>ConcurrentHashMap 和 Hashtable 的区别？<a hidden class=anchor aria-hidden=true href=#concurrenthashmap-和-hashtable-的区别>#</a></h3><table><thead><tr><th>特征</th><th>ConcurrentHashMap</th><th>Hashtable</th></tr></thead><tbody><tr><td>线程安全性</td><td>使用分段锁，允许多个线程并发访问不同分段</td><td>使用全局锁，一次只允许一个线程执行读或写操作</td></tr><tr><td>Null 值</td><td>允许 null 键和 null 值</td><td>不允许 null 键或 null 值</td></tr><tr><td>遍历性能</td><td>通常具有更好的遍历性能</td><td>遍历性能相对较差</td></tr><tr><td>类型</td><td>相对较新的现代并发集合类</td><td>旧的、遗留的集合类</td></tr></tbody></table><h3 id=为什么-hashtable-不允许-null-为键或者值>为什么 HashTable 不允许 null 为键或者值？<a hidden class=anchor aria-hidden=true href=#为什么-hashtable-不允许-null-为键或者值>#</a></h3><p>Hashtable 是支持并发操作的，但这引发了一个潜在的问题。当你使用 get(k) 方法来获取对应的 value 时，如果返回的值是 null，你无法确定这个 null 值是由于在 put(k, v) 时 value 被设为 null，还是因为这个 key 从未被映射过。相比之下，HashMap 是非并发的，你可以通过 contains(key) 方法来明确判断键是否存在。</p><p>在支持并发的 Map 上调用 m.contains(key) 和 m.get(key) 之间可能会存在并发变化，这使得准确判断 null 值的来源变得复杂。</p><h2 id=多线程>多线程<a hidden class=anchor aria-hidden=true href=#多线程>#</a></h2><h3 id=进程process和线程thread>进程（Process）和线程（Thread）<a hidden class=anchor aria-hidden=true href=#进程process和线程thread>#</a></h3><table><thead><tr><th>特点</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>定义</td><td>独立的程序实例</td><td>进程内的执行单元</td></tr><tr><td>资源消耗</td><td>需要独立内存和系统资源，开销大</td><td>共享内存和资源，开销小</td></tr><tr><td>通信和同步</td><td>通信需要使用IPC机制，同步较复杂</td><td>直接共享内存，同步相对容易</td></tr><tr><td>安全性</td><td>进程崩溃不影响其他进程，较安全</td><td>一个线程的错误可能影响整个进程的稳定性</td></tr><tr><td>创建和销毁</td><td>创建和销毁进程较慢复杂</td><td>创建和销毁线程较快简单</td></tr><tr><td>并行性</td><td>进程可以在多处理器上并行执行</td><td>线程在多核处理器上并行执行更容易</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://cheneydev.github.io/posts/2023-10-21-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><span class=title>« Prev</span><br><span>设计模式学习笔记</span></a>
<a class=next href=https://cheneydev.github.io/posts/2023-10-14-mysql-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><span class=title>Next »</span><br><span>MySQL 学习笔记</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Java 学习笔记 on twitter" href="https://twitter.com/intent/tweet/?text=Java%20%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-14-java-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java 学习笔记 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-14-java-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;title=Java%20%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&amp;summary=Java%20%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&amp;source=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-14-java-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java 学习笔记 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-14-java-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f&title=Java%20%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java 学习笔记 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-14-java-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java 学习笔记 on whatsapp" href="https://api.whatsapp.com/send?text=Java%20%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%20-%20https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-14-java-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java 学习笔记 on telegram" href="https://telegram.me/share/url?text=Java%20%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2fcheneydev.github.io%2fposts%2f2023-10-14-java-%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://cheneydev.github.io/>Cheney's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>