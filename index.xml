<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Cheney&#39;s blog</title>
    <link>https://cheneydev.github.io/</link>
    <description>Recent content on Cheney&#39;s blog</description>
    <image>
      <title>Cheney&#39;s blog</title>
      <url>https://cheneydev.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://cheneydev.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 14 Oct 2023 10:38:40 +0800</lastBuildDate><atom:link href="https://cheneydev.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2023 10 14 Java 面试笔记</title>
      <link>https://cheneydev.github.io/posts/2023-10-14-java-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 14 Oct 2023 10:38:40 +0800</pubDate>
      
      <guid>https://cheneydev.github.io/posts/2023-10-14-java-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</guid>
      <description>abstract 和 interface 抽象类（abstract class）是一种类，可以包含抽象方法和具体方法，支持单一继承，而接口（interface）是一种纯抽象类型，只包含抽象方法，支持多重继承。
特点 抽象类 接口 类型 类 接口（纯抽象类型） 方法 可包含抽象方法和具体方法 只包含抽象方法，没有具体方法 字段 可包含字段 不包含字段 继承和实现 可以继承一个抽象类 类可以实现多个接口 多重继承 不支持多重继承 类可以同时实现多个接口 实例化 不能实例化 不能实例化 访问修饰符 可以使用各种访问修饰符（public、protected、private等） 方法默认为public和abstract 方法覆盖（重写） 子类必须覆盖抽象方法，除非子类也是抽象类 实现类必须提供接口中定义的所有方法的具体实现 用途 构建类层次结构，提供通用实现和规范 定义契约，实现多态，允许类共享通用方法 在Java中，abstract和interface都是用于实现抽象性和多态性的关键字，但它们有不同的用途和特点。以下是它们的区别和联系：
Abstract（抽象类）：
特点：
抽象类是一种类，它可以包含抽象方法（即没有方法体的方法）和具体方法（有方法体的方法）。 抽象类可以包含字段（成员变量）。 抽象类可以被继承，但不能被实例化。 子类必须实现（覆盖）抽象类中的所有抽象方法，除非子类自身也是抽象类。 用途：
抽象类通常用于创建类层次结构，其中父类包含通用的属性和方法，但其中某些方法的实现需要由子类提供。 抽象类提供了代码的重用性和封装性。 Interface（接口）：
特点：
接口是一种纯抽象类型，它只包含抽象方法，没有字段和具体方法。 类可以实现多个接口（多重继承），但一个类只能继承一个父类。 接口中的方法默认是public和abstract的，不需要显式地标记为这两个关键字。 实现接口的类必须提供接口中定义的所有方法的具体实现。 用途：
接口用于定义契约，规定实现该接口的类必须提供哪些方法。这有助于实现多态和松耦合。 接口允许不同类之间共享一组通用的方法，而这些类可能属于不同的继承层次结构。 联系和区别：
联系：
抽象类和接口都用于实现多态，即一个类可以表现出多种行为。 抽象类和接口都可以被其他类继承或实现。 区别：
抽象类可以包含具体方法，而接口只能包含抽象方法。 一个类只能继承一个抽象类，但可以实现多个接口。 抽象类可以有字段，而接口不能包含字段。 抽象类用于构建类层次结构，接口用于定义契约。 抽象类使用extends关键字继承，接口使用implements关键字实现。 抽象类的目的是共享通用代码，接口的目的是定义合同。 </description>
    </item>
    
    <item>
      <title>MySQL 面试笔记</title>
      <link>https://cheneydev.github.io/posts/2023-10-14-mysql-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 14 Oct 2023 10:15:02 +0800</pubDate>
      
      <guid>https://cheneydev.github.io/posts/2023-10-14-mysql-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</guid>
      <description>事务 什么是事务 事务就是一组SQL语句，作为一个工作单元以原子方式进行处理。要么全部执行成功，要么全部执行失败。
事务四大特性 ACID 原子性（atomicity）
一个事务必须被视为一个不可分割的工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。
一致性（consistency）
数据库总是从一个一致性状态转换到下一个一致性状态。如果事务最终没有提交，该事务所做的任何修改都不会被保存到数据库中。
隔离性（isolation）
一个事务所做的修改在最终提交以前，对其他事务是不可见的。
持久性（durability）
一旦提交，事务所做的修改就会被永久保存到数据库中。此时即使系统崩溃，数据也不会丢失。
事务的四个隔离级别 READ UNCOMMITTED（未提交读）
在事务中可以查看其他事务中还没有提交的修改。
READ COMMITTED（提交读）
大多数数据库系统的默认隔离级别是READ COMMITTED（但MySQL不是）。一个事务可以看到其他事务在它开始之后提交的修改，但在该事务提交之前，其所做的任何修改对其他事务都是不可见的。这个级别仍然允许不可重复读（nonrepeatable read），这意味着同一事务中两次执行相同语句，可能会看到不同的数据结果。
REPEATABLE READ（可重复读）
MySQL 的默认隔离级别，REPEATABLE READ解决了READ COMMITTED[7]级别的不可重复读问题，保证了在同一个事务中多次读取相同行数据的结果是一样的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（phantom read）的问题。
SERIALIZABLE（串行化）
该级别通过强制事务按序执行，使不同事务之间不可能产生冲突，从而解决了前面说的幻读问题。
死锁 死锁是指两个或多个事务相互持有和请求相同资源上的锁，产生了循环依赖。当多个事务试图以不同的顺序锁定资源时会导致死锁。当多个事务锁定相同的资源时，也可能会发生死锁。</description>
    </item>
    
    <item>
      <title>在 Spring Boot 项目的配置文件中安全存放敏感信息（密码）</title>
      <link>https://cheneydev.github.io/posts/2023-06-01-%E5%9C%A8springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%89%E5%85%A8%E5%AD%98%E6%94%BE%E5%AF%86%E7%A0%81/</link>
      <pubDate>Thu, 01 Jun 2023 10:50:08 +0800</pubDate>
      
      <guid>https://cheneydev.github.io/posts/2023-06-01-%E5%9C%A8springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%89%E5%85%A8%E5%AD%98%E6%94%BE%E5%AF%86%E7%A0%81/</guid>
      <description>实现在 Spring Boot 项目中安全地存储敏感信息，可以使用外部配置文件而不是将敏感信息明文存储在 application.yml 文件中。这样可以避免敏感信息被 Git 提交到网络上。
操作方法：
在 .gitignore 文件中添加 **/credentials.properties 来让版本控制工具忽略这个文件。
在 resources 文件夹下创建 credentials.properties，用来存储密码等敏感信息。
将敏感信息添加到credentials.properties文件中。例如：
password=your_password_here 在配置类上使用 @PropertySource 注解，指定加载刚才的文件。这样可以把文件的内容加载到 Spring Context 中。
在配置文件中使用（以配置 MySQL 数据源为例）：
spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://${mysql-host}:${mysql-port}/${mysql-database}?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true username: ${mysql-username} password: ${mysql-password} </description>
    </item>
    
    <item>
      <title>如何使用 AI 孙燕姿歌手模型</title>
      <link>https://cheneydev.github.io/posts/2023-05-30-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8ai%E5%AD%99%E7%87%95%E5%A7%BF%E6%AD%8C%E6%89%8B%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Tue, 30 May 2023 21:40:40 +0800</pubDate>
      
      <guid>https://cheneydev.github.io/posts/2023-05-30-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8ai%E5%AD%99%E7%87%95%E5%A7%BF%E6%AD%8C%E6%89%8B%E6%A8%A1%E5%9E%8B/</guid>
      <description>实现 AI 孙燕姿主要借助 so-vits-svc 和别人基于此项目训练出来的孙燕姿声音模型。
项目中提供了 Colab 版本的代码，所以这里介绍如何在 Colab 中运行此项目并导入孙燕姿声音模型。
初始化模型 将 Colab 文件保存到自己的 Google Drive ，依次运行各个 Cell ，在 (Optional) Other Downloads (.zip) Step o.1 这一步导入孙燕姿模型。首先将下载好的孙燕姿模型上传到自己的 Google Drive （这里不提供链接），右键获取该文件的分享链接（所有人可见），输入到 Cell 的 model_url 里。然后运行下一个 Cell ，注意下一个 Cell 下面的重启运行时环境的提示，需要手动重启运行时环境，重启后不需要从头开始执行，接着运行下面的 Cell 即可。
处理音频文件 我们需要将目标歌曲的伴奏和人声分离，我使用的是 vocalremover.org 这个网站，将分离后的伴奏和人声分别下载保存。
注意，由于性能限制，我们需要把人声音频切分成 1 分钟左右的片段来交给模型处理，然后将输出音频合并成完整的歌曲人声部分。
人声文件是我们需要丢给模型处理的文件，当模型把人声替换成孙燕姿的声音之后，我们将它下载下来并与刚才的伴奏合并（我使用的是剪映在线版）。
生成孙燕姿音色歌曲 在 Colab 的文件目录中找到 raw 文件夹，将人声文件放进去。
点击运行下一个 Cell ，运行完毕后会出来如下表单：
参数这里建议像图里那样填写。
然后点击 convert 等待完成。
输出结果在 outputs 文件夹下，点击下载即可。</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://cheneydev.github.io/posts/hello-world/</link>
      <pubDate>Thu, 25 May 2023 10:49:08 +0800</pubDate>
      
      <guid>https://cheneydev.github.io/posts/hello-world/</guid>
      <description>Hello World!</description>
    </item>
    
  </channel>
</rss>
